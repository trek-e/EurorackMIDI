---
phase: 03-device-profiles
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/Views/ControlSurfaces/PadButtonView.swift
  - Sources/Views/ControlSurfaces/PianoKeyboardView.swift
  - Sources/Views/ControlSurfaces/PerformancePadsView.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Velocity curve from profile affects MIDI output velocity"
    - "Fixed velocity setting sends configured value instead of 100"
    - "Soft/Hard/Linear curves transform touch input appropriately"
  artifacts:
    - path: "Sources/Views/ControlSurfaces/PadButtonView.swift"
      provides: "Velocity curve application for pads"
      contains: "velocityCurve.toMIDIVelocity"
    - path: "Sources/Views/ControlSurfaces/PianoKeyboardView.swift"
      provides: "Velocity curve application for keyboard"
      contains: "velocityCurve.toMIDIVelocity"
  key_links:
    - from: "PadButtonView"
      to: "VelocityCurve"
      via: "toMIDIVelocity call in sendNoteOn"
      pattern: "velocityCurve\\.toMIDIVelocity"
    - from: "WhiteKeyView/BlackKeyView"
      to: "VelocityCurve"
      via: "toMIDIVelocity call in sendNoteOn"
      pattern: "velocityCurve\\.toMIDIVelocity"
---

<objective>
Wire velocity curves from device profiles to control surface MIDI output.

Purpose: Close the gap where velocity curve settings in profiles have no effect on actual MIDI output. Currently PadButtonView, WhiteKeyView, and BlackKeyView all send hardcoded velocity 100, ignoring the profile's velocityCurve and fixedVelocity settings.

Output: Control surfaces that apply velocity transformations based on profile settings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-device-profiles/03-04-SUMMARY.md
@.planning/phases/03-device-profiles/03-VERIFICATION.md

@Sources/Models/VelocityCurve.swift
@Sources/Models/DeviceProfile.swift
@Sources/Managers/MIDIConnectionManager.swift
@Sources/Views/ControlSurfaces/PadButtonView.swift
@Sources/Views/ControlSurfaces/PianoKeyboardView.swift
@Sources/Views/ControlSurfaces/PerformancePadsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add velocity curve to PadButtonView</name>
  <files>Sources/Views/ControlSurfaces/PadButtonView.swift</files>
  <action>
Modify PadButtonView to accept and apply velocity curve:

1. Add new properties to PadButtonView:
   - `let velocityCurve: VelocityCurve`
   - `let fixedVelocity: Int?`

2. Update init/struct to accept these parameters

3. Replace hardcoded velocity in sendNoteOn:
   - BEFORE: `try? manager.sendNoteOn(note: note, velocity: 100)`
   - AFTER: `try? manager.sendNoteOn(note: note, velocity: velocityCurve.toMIDIVelocity(from: 1.0, fixedValue: fixedVelocity))`

Note: Using 1.0 as normalizedInput since touch screens don't have pressure sensitivity. Future enhancement could add pressure/3D touch support.
  </action>
  <verify>
Swift build succeeds: `swift build 2>&1 | head -50`
Grep confirms velocity curve usage: `grep -n "toMIDIVelocity" Sources/Views/ControlSurfaces/PadButtonView.swift`
  </verify>
  <done>PadButtonView uses velocityCurve.toMIDIVelocity() instead of hardcoded 100</done>
</task>

<task type="auto">
  <name>Task 2: Add velocity curve to WhiteKeyView and BlackKeyView</name>
  <files>Sources/Views/ControlSurfaces/PianoKeyboardView.swift</files>
  <action>
Modify WhiteKeyView and BlackKeyView to accept and apply velocity curve:

1. Add properties to WhiteKeyView:
   - `let velocityCurve: VelocityCurve`
   - `let fixedVelocity: Int?`

2. Add same properties to BlackKeyView

3. Update both views' sendNoteOn calls:
   - BEFORE: `try? manager.sendNoteOn(note: note, velocity: 100)`
   - AFTER: `try? manager.sendNoteOn(note: note, velocity: velocityCurve.toMIDIVelocity(from: 1.0, fixedValue: fixedVelocity))`

4. Update PianoOctaveView to pass velocity parameters to WhiteKeyView and BlackKeyView:
   - Add `let velocityCurve: VelocityCurve` and `let fixedVelocity: Int?` properties
   - Pass through to WhiteKeyView and BlackKeyView constructors

5. Update PianoKeyboardView to pass velocity parameters to PianoOctaveView:
   - Get velocity from MIDIConnectionManager.shared.currentProfile
   - Pass profile?.velocityCurve ?? .linear and profile?.fixedVelocity to PianoOctaveView
  </action>
  <verify>
Swift build succeeds: `swift build 2>&1 | head -50`
Grep confirms velocity curve in both key views: `grep -n "toMIDIVelocity" Sources/Views/ControlSurfaces/PianoKeyboardView.swift`
  </verify>
  <done>WhiteKeyView and BlackKeyView use velocityCurve.toMIDIVelocity() instead of hardcoded 100</done>
</task>

<task type="auto">
  <name>Task 3: Update PerformancePadsView to pass velocity to PadButtonView</name>
  <files>Sources/Views/ControlSurfaces/PerformancePadsView.swift</files>
  <action>
Update PerformancePadsView to pass velocity curve to PadButtonView:

1. Get velocity curve from profile in PerformancePadsView:
   - Access MIDIConnectionManager.shared.currentProfile
   - Use profile?.velocityCurve ?? .linear as default
   - Use profile?.fixedVelocity

2. Update PadButtonView instantiation in ForEach:
   - BEFORE: `PadButtonView(note: note, label: "Pad \(index + 1)", manager: manager)`
   - AFTER: `PadButtonView(note: note, label: "Pad \(index + 1)", manager: manager, velocityCurve: velocityCurve, fixedVelocity: fixedVelocity)`

Where velocityCurve and fixedVelocity are computed properties that read from manager.currentProfile.
  </action>
  <verify>
Swift build succeeds: `swift build 2>&1 | head -50`
Grep confirms velocity passed to PadButtonView: `grep -n "velocityCurve" Sources/Views/ControlSurfaces/PerformancePadsView.swift`
  </verify>
  <done>PerformancePadsView passes velocity curve from profile to PadButtonView</done>
</task>

</tasks>

<verification>
1. Build verification: `swift build` succeeds without errors
2. Code verification:
   - `grep -rn "velocity: 100" Sources/Views/ControlSurfaces/` returns no matches
   - `grep -rn "toMIDIVelocity" Sources/Views/ControlSurfaces/` shows usage in all 3 files
3. Profile wiring: All control surfaces read velocityCurve from currentProfile
</verification>

<success_criteria>
- No hardcoded velocity values (100) in control surface files
- VelocityCurve.toMIDIVelocity() called for all MIDI note-on events
- Velocity curve reads from MIDIConnectionManager.currentProfile
- Swift build passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-device-profiles/03-05-SUMMARY.md`
</output>
