---
phase: 03-device-profiles
plan: 06
type: execute
wave: 2
depends_on: [03-05]
files_modified:
  - Sources/Views/ControlSurfaces/PianoKeyboardView.swift
  - Sources/Views/ControlSurfaces/PerformancePadsView.swift
  - Sources/Views/ContentView.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Keyboard octave offset persists to profile when changed"
    - "Keyboard octave offset loads from profile on device selection"
    - "Pad octave offset persists to profile when changed"
    - "Pad octave offset loads from profile on device selection"
    - "Pad mapping mode affects note calculation (GM Drum vs Chromatic vs Custom)"
  artifacts:
    - path: "Sources/Views/ControlSurfaces/PianoKeyboardView.swift"
      provides: "Keyboard octave persistence"
      contains: "profileManager.saveProfile"
    - path: "Sources/Views/ControlSurfaces/PerformancePadsView.swift"
      provides: "Pad octave persistence and mapping mode"
      contains: "padMappingMode"
  key_links:
    - from: "PianoKeyboardView"
      to: "ProfileManager"
      via: "saveProfile on octave change"
      pattern: "profileManager\\.saveProfile"
    - from: "PerformancePadsView"
      to: "ProfileManager"
      via: "saveProfile on octave change"
      pattern: "profileManager\\.saveProfile"
    - from: "PerformancePadsView"
      to: "PadMappingMode"
      via: "note calculation switch"
      pattern: "switch.*padMappingMode"
---

<objective>
Wire octave offsets and pad mapping mode from device profiles to control surfaces.

Purpose: Close the gaps where (1) octave offset changes are lost on device switch or app restart because they're stored in local @State instead of profiles, and (2) pad mapping mode settings have no effect because note calculation hardcodes chromatic mode.

Output: Control surfaces that persist octave changes to profiles and respect pad mapping mode for note calculation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-device-profiles/03-05-SUMMARY.md
@.planning/phases/03-device-profiles/03-VERIFICATION.md

@Sources/Models/DeviceProfile.swift
@Sources/Models/PadMappingMode.swift
@Sources/Managers/ProfileManager.swift
@Sources/Managers/MIDIConnectionManager.swift
@Sources/Views/ControlSurfaces/PianoKeyboardView.swift
@Sources/Views/ControlSurfaces/PerformancePadsView.swift
@Sources/Views/ContentView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Persist keyboard octave offset to profile</name>
  <files>Sources/Views/ControlSurfaces/PianoKeyboardView.swift</files>
  <action>
Update PianoKeyboardView to read/write octave offset from/to profile:

1. Add ProfileManager reference:
   - `@State private var profileManager = ProfileManager.shared`

2. Change octaveOffset initialization to load from profile on appear:
   - Keep `@State private var octaveOffset: Int = 0` as local state for UI responsiveness
   - Add `.onAppear` to load from profile:
     ```swift
     .onAppear {
         if let device = manager.selectedDevice {
             let profile = profileManager.profile(for: device.uniqueID)
             octaveOffset = profile.keyboardOctaveOffset
         }
     }
     ```

3. Add `.onChange(of: manager.selectedDevice)` to reload when device changes:
   ```swift
   .onChange(of: manager.selectedDevice) { _, newDevice in
       if let device = newDevice {
           let profile = profileManager.profile(for: device.uniqueID)
           octaveOffset = profile.keyboardOctaveOffset
       }
   }
   ```

4. Add `.onChange(of: octaveOffset)` to save to profile:
   ```swift
   .onChange(of: octaveOffset) { _, newOffset in
       guard let device = manager.selectedDevice else { return }
       var profile = profileManager.profile(for: device.uniqueID)
       profile.keyboardOctaveOffset = newOffset
       profileManager.saveProfile(profile, for: device.uniqueID)
   }
   ```
  </action>
  <verify>
Swift build succeeds: `swift build 2>&1 | head -50`
Grep confirms profile save: `grep -n "keyboardOctaveOffset" Sources/Views/ControlSurfaces/PianoKeyboardView.swift`
  </verify>
  <done>Keyboard octave offset loads from profile on device selection and saves on change</done>
</task>

<task type="auto">
  <name>Task 2: Persist pad octave offset and apply pad mapping mode</name>
  <files>Sources/Views/ControlSurfaces/PerformancePadsView.swift</files>
  <action>
Update PerformancePadsView to read/write octave offset and apply pad mapping mode:

1. Add ProfileManager reference:
   - `@State private var profileManager = ProfileManager.shared`

2. Add octave offset load/save like PianoKeyboardView:
   - `.onAppear` to load `profile.padOctaveOffset`
   - `.onChange(of: manager.selectedDevice)` to reload on device change
   - `.onChange(of: octaveOffset)` to save to profile

3. Replace hardcoded chromatic note calculation with mapping mode logic.
   Current (hardcoded chromatic):
   ```swift
   private var notes: [UInt7] {
       let baseNote = UInt7(12 * (baseOctave + octaveOffset))
       return (0..<padCount).map { UInt7($0) + baseNote }
   }
   ```

   New (respects padMappingMode):
   ```swift
   private var notes: [UInt7] {
       guard let device = manager.selectedDevice else {
           // Default chromatic fallback
           let baseNote = UInt7(12 * (baseOctave + octaveOffset))
           return (0..<padCount).map { UInt7($0) + baseNote }
       }

       let profile = profileManager.profile(for: device.uniqueID)

       switch profile.padMappingMode {
       case .gmDrum:
           // GM Drum: Fixed notes 36-51 (Kick=36, Snare=38, etc.)
           // With octave offset applied
           let baseNote = UInt7(36 + (octaveOffset * 12))
           return (0..<padCount).map { UInt7($0) + baseNote }

       case .chromaticBase:
           // Chromatic from profile's padBaseNote
           let baseNote = UInt7(profile.padBaseNote + (octaveOffset * 12))
           return (0..<padCount).map { UInt7($0) + baseNote }

       case .custom:
           // Custom note mapping from profile (ignore octave offset for full control)
           if let customNotes = profile.customPadNotes, customNotes.count == padCount {
               return customNotes.map { UInt7(clamping: $0) }
           }
           // Fallback to chromatic if custom not configured
           let baseNote = UInt7(profile.padBaseNote + (octaveOffset * 12))
           return (0..<padCount).map { UInt7($0) + baseNote }
       }
   }
   ```
  </action>
  <verify>
Swift build succeeds: `swift build 2>&1 | head -50`
Grep confirms mapping mode: `grep -n "padMappingMode" Sources/Views/ControlSurfaces/PerformancePadsView.swift`
Grep confirms octave save: `grep -n "padOctaveOffset" Sources/Views/ControlSurfaces/PerformancePadsView.swift`
  </verify>
  <done>Pad octave offset persists to profile; pad mapping mode determines note calculation</done>
</task>

<task type="auto">
  <name>Task 3: Ensure profile changes propagate to control surfaces</name>
  <files>Sources/Views/ContentView.swift</files>
  <action>
Verify ContentView properly triggers profile reload on device changes. The existing implementation already has:

```swift
.onChange(of: manager.selectedDevice) { _, newDevice in
    if let device = newDevice {
        let profile = profileManager.profile(for: device.uniqueID)
        selectedTab = profile.defaultTab
    }
}
```

This is sufficient because:
1. PianoKeyboardView and PerformancePadsView both observe manager.selectedDevice
2. When device changes, they reload their octave offsets from profile
3. No additional wiring needed in ContentView

However, ensure MIDIConnectionManager.currentProfile is updated when device changes. Check if applyProfile is called on manual device selection (not just auto-reconnect).

If needed, add to ContentView's onChange:
```swift
.onChange(of: manager.selectedDevice) { _, newDevice in
    if let device = newDevice {
        let profile = profileManager.profile(for: device.uniqueID)
        selectedTab = profile.defaultTab
        manager.applyProfile(profile)  // Ensure currentProfile is set
    }
}
```

This ensures currentProfile is always valid for velocity curve lookups in control surfaces.
  </action>
  <verify>
Swift build succeeds: `swift build 2>&1 | head -50`
Grep confirms applyProfile on device change: `grep -n "applyProfile" Sources/Views/ContentView.swift`
  </verify>
  <done>Profile is applied when device is selected, ensuring currentProfile is always valid</done>
</task>

</tasks>

<verification>
1. Build verification: `swift build` succeeds without errors
2. Octave persistence:
   - `grep -n "keyboardOctaveOffset" Sources/Views/ControlSurfaces/PianoKeyboardView.swift` shows load and save
   - `grep -n "padOctaveOffset" Sources/Views/ControlSurfaces/PerformancePadsView.swift` shows load and save
3. Pad mapping mode:
   - `grep -n "padMappingMode" Sources/Views/ControlSurfaces/PerformancePadsView.swift` shows switch statement
4. Profile propagation:
   - `grep -n "applyProfile" Sources/Views/ContentView.swift` shows profile applied on device selection
</verification>

<success_criteria>
- Keyboard octave offset reads from profile on device selection
- Keyboard octave offset saves to profile on change
- Pad octave offset reads from profile on device selection
- Pad octave offset saves to profile on change
- Pad note calculation respects padMappingMode (gmDrum/chromaticBase/custom)
- currentProfile is set on manual device selection (not just auto-reconnect)
- Swift build passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-device-profiles/03-06-SUMMARY.md`
</output>
