---
phase: 04-sequencing
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - Sources/Sequencer/Views/PianoRollGridView.swift
  - Sources/Sequencer/Views/SequencerView.swift
autonomous: true

must_haves:
  truths:
    - "User can see a grid representing steps and notes"
    - "User can tap to place notes on the grid"
    - "User can tap existing notes to remove them"
    - "Grid scrolls to show full pitch range"
  artifacts:
    - path: "Sources/Sequencer/Views/PianoRollGridView.swift"
      provides: "Canvas-based piano roll grid for note editing"
      min_lines: 100
      contains: "Canvas"
    - path: "Sources/Sequencer/Views/SequencerView.swift"
      provides: "Main sequencer container view"
      min_lines: 50
  key_links:
    - from: "Sources/Sequencer/Views/PianoRollGridView.swift"
      to: "Sources/Sequencer/Models/Pattern.swift"
      via: "displays and edits Pattern track notes"
      pattern: "Pattern"
    - from: "Sources/Sequencer/Views/SequencerView.swift"
      to: "Sources/Sequencer/Managers/PatternManager.swift"
      via: "loads current pattern for editing"
      pattern: "PatternManager"
---

<objective>
Create piano roll grid UI for step sequencer note editing.

Purpose: Provide an intuitive tap-to-place interface for creating musical patterns. Users tap cells to add/remove notes, with a piano roll layout showing pitch vertically and time horizontally.

Output: PianoRollGridView using SwiftUI Canvas for high-performance rendering, SequencerView as container.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-sequencing/04-CONTEXT.md
@.planning/phases/04-sequencing/04-RESEARCH.md
@Sources/Sequencer/Models/Pattern.swift
@Sources/Sequencer/Managers/PatternManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PianoRollGridView with Canvas rendering</name>
  <files>
    Sources/Sequencer/Views/PianoRollGridView.swift
  </files>
  <action>
Create PianoRollGridView.swift using SwiftUI Canvas for performance:

```swift
import SwiftUI

/// Piano roll grid for editing step sequencer notes
struct PianoRollGridView: View {
    @Binding var track: Track
    let stepCount: Int

    // Display range (MIDI notes to show)
    @State private var lowestNote: UInt8 = 36  // C2
    @State private var visibleNoteRange: UInt8 = 24  // 2 octaves

    // Grid configuration
    private let minCellWidth: CGFloat = 40
    private let cellHeight: CGFloat = 24
    private let pianoKeyWidth: CGFloat = 40

    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                // Piano keys column
                pianoKeysView

                // Scrollable grid
                ScrollView([.horizontal, .vertical], showsIndicators: true) {
                    gridCanvas(size: gridSize(for: geometry))
                        .frame(
                            width: gridSize(for: geometry).width,
                            height: gridSize(for: geometry).height
                        )
                }
            }
        }
    }

    // MARK: - Grid Size

    private func gridSize(for geometry: GeometryProxy) -> CGSize {
        let width = max(CGFloat(stepCount) * minCellWidth, geometry.size.width - pianoKeyWidth)
        let height = CGFloat(visibleNoteRange) * cellHeight
        return CGSize(width: width, height: height)
    }

    // MARK: - Piano Keys

    private var pianoKeysView: some View {
        VStack(spacing: 0) {
            ForEach((0..<Int(visibleNoteRange)).reversed(), id: \.self) { offset in
                let noteNumber = lowestNote + UInt8(offset)
                PianoKeyLabel(note: noteNumber)
                    .frame(width: pianoKeyWidth, height: cellHeight)
            }
        }
    }

    // MARK: - Grid Canvas

    private func gridCanvas(size: CGSize) -> some View {
        Canvas { context, canvasSize in
            let cellWidth = canvasSize.width / CGFloat(stepCount)

            // Draw grid lines
            drawGridLines(context: context, size: canvasSize, cellWidth: cellWidth)

            // Draw notes
            drawNotes(context: context, size: canvasSize, cellWidth: cellWidth)
        }
        .drawingGroup()  // Metal-backed rendering
        .contentShape(Rectangle())
        .gesture(
            DragGesture(minimumDistance: 0)
                .onEnded { value in
                    handleTap(at: value.location, in: size)
                }
        )
    }

    // MARK: - Drawing

    private func drawGridLines(context: GraphicsContext, size: CGSize, cellWidth: CGFloat) {
        // Vertical lines (step divisions)
        for step in 0...stepCount {
            let x = CGFloat(step) * cellWidth
            let isBeatLine = step % 4 == 0

            var path = Path()
            path.move(to: CGPoint(x: x, y: 0))
            path.addLine(to: CGPoint(x: x, y: size.height))

            context.stroke(
                path,
                with: .color(isBeatLine ? .gray : .gray.opacity(0.3)),
                lineWidth: isBeatLine ? 1 : 0.5
            )
        }

        // Horizontal lines (note divisions)
        for row in 0...Int(visibleNoteRange) {
            let y = CGFloat(row) * cellHeight
            let noteNumber = lowestNote + UInt8(Int(visibleNoteRange) - row)
            let isC = noteNumber % 12 == 0  // C notes

            var path = Path()
            path.move(to: CGPoint(x: 0, y: y))
            path.addLine(to: CGPoint(x: size.width, y: y))

            context.stroke(
                path,
                with: .color(isC ? .blue.opacity(0.5) : .gray.opacity(0.2)),
                lineWidth: isC ? 1 : 0.5
            )

            // Shade black keys
            if [1, 3, 6, 8, 10].contains(Int(noteNumber) % 12) {
                let rect = CGRect(x: 0, y: y, width: size.width, height: cellHeight)
                context.fill(Path(rect), with: .color(.black.opacity(0.05)))
            }
        }
    }

    private func drawNotes(context: GraphicsContext, size: CGSize, cellWidth: CGFloat) {
        for note in track.notes {
            // Check if note is in visible range
            guard note.note >= lowestNote && note.note < lowestNote + visibleNoteRange else { continue }

            let row = Int(lowestNote + visibleNoteRange - 1 - note.note)
            let rect = CGRect(
                x: CGFloat(note.step) * cellWidth + 2,
                y: CGFloat(row) * cellHeight + 2,
                width: cellWidth * CGFloat(note.duration) - 4,
                height: cellHeight - 4
            )

            // Note color based on velocity
            let velocityAlpha = Double(note.velocity) / 127.0
            let noteColor = Color.green.opacity(0.5 + velocityAlpha * 0.5)

            context.fill(
                Path(roundedRect: rect, cornerRadius: 3),
                with: .color(noteColor)
            )

            // Note border
            context.stroke(
                Path(roundedRect: rect, cornerRadius: 3),
                with: .color(.green),
                lineWidth: 1
            )
        }
    }

    // MARK: - Interaction

    private func handleTap(at location: CGPoint, in size: CGSize) {
        let cellWidth = size.width / CGFloat(stepCount)

        let step = Int(location.x / cellWidth)
        let row = Int(location.y / cellHeight)
        let noteNumber = lowestNote + visibleNoteRange - 1 - UInt8(row)

        guard step >= 0 && step < stepCount else { return }
        guard noteNumber >= lowestNote && noteNumber < lowestNote + visibleNoteRange else { return }

        // Toggle note: remove if exists, add if not
        if let existingNote = track.notes.first(where: { $0.step == step && $0.note == noteNumber }) {
            track.removeNote(id: existingNote.id)
        } else {
            let newNote = StepNote(step: step, note: noteNumber, velocity: 100, duration: 1.0)
            track.addNote(newNote)
        }
    }
}

// MARK: - Piano Key Label

struct PianoKeyLabel: View {
    let note: UInt8

    var body: some View {
        ZStack {
            Rectangle()
                .fill(isBlackKey ? Color.black : Color.white)
                .border(Color.gray.opacity(0.3), width: 0.5)

            if note % 12 == 0 {  // C notes
                Text(noteName)
                    .font(.caption2)
                    .foregroundColor(isBlackKey ? .white : .black)
            }
        }
    }

    private var isBlackKey: Bool {
        [1, 3, 6, 8, 10].contains(Int(note) % 12)
    }

    private var noteName: String {
        let octave = Int(note) / 12 - 1
        return "C\(octave)"
    }
}

#Preview {
    @Previewable @State var track = Track(
        channel: 1,
        notes: [
            StepNote(step: 0, note: 60, velocity: 100, duration: 1.0),
            StepNote(step: 4, note: 62, velocity: 80, duration: 1.0),
            StepNote(step: 8, note: 64, velocity: 100, duration: 2.0)
        ]
    )

    PianoRollGridView(track: $track, stepCount: 16)
        .frame(height: 300)
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PianoRollGridView compiles and renders in preview
  </verify>
  <done>
PianoRollGridView renders a scrollable piano roll grid using Canvas, with piano keys on the left and a tappable note grid.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add note editing controls</name>
  <files>
    Sources/Sequencer/Views/PianoRollGridView.swift
  </files>
  <action>
Enhance PianoRollGridView with note editing capabilities:

```swift
// Add properties for editing state:
@State private var selectedNoteId: UUID?
@State private var showNoteEditor: Bool = false

// Add velocity and duration editing sheet:
private var noteEditorSheet: some View {
    Group {
        if let noteId = selectedNoteId,
           let noteIndex = track.notes.firstIndex(where: { $0.id == noteId }) {
            NoteEditorView(
                note: $track.notes[noteIndex],
                onDelete: {
                    track.removeNote(id: noteId)
                    showNoteEditor = false
                    selectedNoteId = nil
                }
            )
        }
    }
}

// Update handleTap to support long-press for editing:
// Replace simple tap with combined gesture
.simultaneousGesture(
    LongPressGesture(minimumDuration: 0.5)
        .sequenced(before: DragGesture(minimumDistance: 0))
        .onEnded { value in
            switch value {
            case .second(true, let drag):
                if let location = drag?.location {
                    handleLongPress(at: location, in: size)
                }
            default:
                break
            }
        }
)

private func handleLongPress(at location: CGPoint, in size: CGSize) {
    let cellWidth = size.width / CGFloat(stepCount)
    let step = Int(location.x / cellWidth)
    let row = Int(location.y / cellHeight)
    let noteNumber = lowestNote + visibleNoteRange - 1 - UInt8(row)

    // Find note at this position
    if let note = track.notes.first(where: { $0.step == step && $0.note == noteNumber }) {
        selectedNoteId = note.id
        showNoteEditor = true
    }
}

// Add to body:
.sheet(isPresented: $showNoteEditor) {
    noteEditorSheet
}
```

Create NoteEditorView for editing velocity and duration:

```swift
struct NoteEditorView: View {
    @Binding var note: StepNote
    let onDelete: () -> Void
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            Form {
                Section("Note") {
                    HStack {
                        Text("Pitch")
                        Spacer()
                        Text(noteName(for: note.note))
                            .foregroundColor(.secondary)
                    }

                    HStack {
                        Text("Step")
                        Spacer()
                        Text("\(note.step + 1)")
                            .foregroundColor(.secondary)
                    }
                }

                Section("Velocity") {
                    Slider(
                        value: Binding(
                            get: { Double(note.velocity) },
                            set: { note.velocity = UInt8($0) }
                        ),
                        in: 1...127,
                        step: 1
                    )
                    Text("\(note.velocity)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                Section("Duration") {
                    Picker("Duration", selection: $note.duration) {
                        Text("1/4 step").tag(0.25)
                        Text("1/2 step").tag(0.5)
                        Text("1 step").tag(1.0)
                        Text("2 steps").tag(2.0)
                        Text("4 steps").tag(4.0)
                    }
                }

                Section {
                    Button(role: .destructive) {
                        onDelete()
                    } label: {
                        HStack {
                            Spacer()
                            Text("Delete Note")
                            Spacer()
                        }
                    }
                }
            }
            .navigationTitle("Edit Note")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                }
            }
        }
        .presentationDetents([.medium])
    }

    private func noteName(for midiNote: UInt8) -> String {
        let noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
        let octave = Int(midiNote) / 12 - 1
        let noteName = noteNames[Int(midiNote) % 12]
        return "\(noteName)\(octave)"
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
Long-press opens note editor sheet
  </verify>
  <done>
PianoRollGridView supports tap to toggle notes and long-press to edit velocity/duration via sheet.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SequencerView container</name>
  <files>
    Sources/Sequencer/Views/SequencerView.swift
  </files>
  <action>
Create SequencerView.swift as the main sequencer container:

```swift
import SwiftUI

/// Main sequencer view containing grid, track selection, and controls
struct SequencerView: View {
    @ObservedObject private var patternManager = PatternManager.shared
    @State private var pattern: Pattern = Pattern.newPattern()
    @State private var selectedTrackIndex: Int = 0
    @State private var showPatternBrowser: Bool = false

    var body: some View {
        VStack(spacing: 0) {
            // Transport (always visible)
            TransportView()

            Divider()

            // Pattern info bar
            patternInfoBar

            Divider()

            // Track tabs
            if pattern.tracks.count > 1 {
                trackTabBar
            }

            // Piano roll grid
            if selectedTrackIndex < pattern.tracks.count {
                PianoRollGridView(
                    track: $pattern.tracks[selectedTrackIndex],
                    stepCount: pattern.stepCount
                )
            }

            Divider()

            // Bottom toolbar
            bottomToolbar
        }
        .sheet(isPresented: $showPatternBrowser) {
            PatternBrowserSheet(
                onSelect: { selectedPattern in
                    pattern = selectedPattern
                    selectedTrackIndex = 0
                }
            )
        }
        .onChange(of: pattern) { _, newPattern in
            // Auto-save on changes
            if let currentPattern = patternManager.currentPattern,
               let location = findPatternLocation(id: currentPattern.id) {
                patternManager.savePattern(newPattern, bank: location.bank, slot: location.slot)
            }
        }
    }

    // MARK: - Pattern Info Bar

    private var patternInfoBar: some View {
        HStack {
            Button {
                showPatternBrowser = true
            } label: {
                HStack {
                    Circle()
                        .fill(pattern.color)
                        .frame(width: 12, height: 12)
                    Text(pattern.name)
                        .font(.headline)
                    Image(systemName: "chevron.down")
                        .font(.caption)
                }
            }
            .buttonStyle(.plain)

            Spacer()

            // Step count
            Picker("Steps", selection: $pattern.stepCount) {
                ForEach(Pattern.stepCountPresets, id: \.self) { count in
                    Text("\(count)").tag(count)
                }
            }
            .pickerStyle(.segmented)
            .frame(width: 200)

            Spacer()

            // Swing
            HStack {
                Text("Swing")
                    .font(.caption)
                Slider(value: $pattern.swing, in: 0...1)
                    .frame(width: 80)
                Text("\(Int(pattern.swing * 100))%")
                    .font(.caption)
                    .frame(width: 40)
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
    }

    // MARK: - Track Tab Bar

    private var trackTabBar: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 8) {
                ForEach(Array(pattern.tracks.enumerated()), id: \.element.id) { index, track in
                    TrackTabButton(
                        track: track,
                        isSelected: index == selectedTrackIndex,
                        onSelect: { selectedTrackIndex = index },
                        onMuteToggle: { pattern.tracks[index].isMuted.toggle() },
                        onSoloToggle: { pattern.tracks[index].isSoloed.toggle() }
                    )
                }

                // Add track button
                Button {
                    pattern.addTrack()
                    selectedTrackIndex = pattern.tracks.count - 1
                } label: {
                    Image(systemName: "plus.circle")
                }
                .disabled(pattern.tracks.count >= 16)
            }
            .padding(.horizontal)
        }
        .padding(.vertical, 8)
        .background(Color(.secondarySystemBackground))
    }

    // MARK: - Bottom Toolbar

    private var bottomToolbar: some View {
        HStack {
            // Clear track
            Button {
                pattern.tracks[selectedTrackIndex].clearNotes()
            } label: {
                Label("Clear", systemImage: "trash")
            }

            Spacer()

            // Save pattern
            Button {
                saveCurrentPattern()
            } label: {
                Label("Save", systemImage: "square.and.arrow.down")
            }

            Spacer()

            // New pattern
            Button {
                pattern = Pattern.newPattern()
                selectedTrackIndex = 0
            } label: {
                Label("New", systemImage: "plus")
            }
        }
        .padding()
    }

    // MARK: - Helpers

    private func saveCurrentPattern() {
        if let location = patternManager.savePatternToFirstAvailable(pattern) {
            patternManager.currentPattern = pattern
            ToastManager.shared.show(
                message: "Saved to \(patternManager.slotIdentifier(bank: location.bank, slot: location.slot))",
                type: .success
            )
        } else {
            ToastManager.shared.show(message: "All slots full", type: .warning)
        }
    }

    private func findPatternLocation(id: UUID) -> (bank: Int, slot: Int)? {
        for (bankIndex, bank) in patternManager.banks.enumerated() {
            for (slot, pattern) in bank.patterns.enumerated() {
                if pattern?.id == id {
                    return (bankIndex, slot)
                }
            }
        }
        return nil
    }
}

// MARK: - Track Tab Button

struct TrackTabButton: View {
    let track: Track
    let isSelected: Bool
    let onSelect: () -> Void
    let onMuteToggle: () -> Void
    let onSoloToggle: () -> Void

    var body: some View {
        HStack(spacing: 4) {
            Button(action: onSelect) {
                Text(track.name)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(isSelected ? Color.accentColor : Color(.tertiarySystemBackground))
                    .foregroundColor(isSelected ? .white : .primary)
                    .cornerRadius(4)
            }
            .buttonStyle(.plain)

            // Mute button
            Button(action: onMuteToggle) {
                Text("M")
                    .font(.caption2.bold())
                    .foregroundColor(track.isMuted ? .red : .secondary)
            }
            .buttonStyle(.plain)

            // Solo button
            Button(action: onSoloToggle) {
                Text("S")
                    .font(.caption2.bold())
                    .foregroundColor(track.isSoloed ? .yellow : .secondary)
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Pattern Browser Sheet (placeholder)

struct PatternBrowserSheet: View {
    let onSelect: (Pattern) -> Void
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            Text("Pattern Browser (implemented in Plan 06)")
                .navigationTitle("Select Pattern")
                .toolbar {
                    ToolbarItem(placement: .cancellationAction) {
                        Button("Cancel") { dismiss() }
                    }
                }
        }
    }
}

#Preview {
    SequencerView()
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
SequencerView displays transport, pattern info, track tabs, and grid
  </verify>
  <done>
SequencerView contains TransportView, pattern info bar, track selection tabs, piano roll grid, and bottom toolbar for save/new/clear actions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds without warnings
2. PianoRollGridView renders grid with piano keys
3. Can tap to add/remove notes
4. Can long-press to edit note velocity/duration
5. SequencerView shows transport, pattern info, track tabs, and grid
6. Track mute/solo buttons toggle state visually
7. Can change step count and swing
</verification>

<success_criteria>
- Piano roll grid displays steps horizontally and notes vertically
- Canvas rendering with .drawingGroup() for performance
- Tap toggles note on/off at grid position
- Long-press opens note editor for velocity/duration
- Track tabs allow switching between multiple tracks
- Mute/Solo buttons on each track
- Pattern metadata (name, step count, swing) editable
- Save button persists pattern via PatternManager
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequencing/04-05-SUMMARY.md`
</output>
