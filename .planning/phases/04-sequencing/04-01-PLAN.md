---
phase: 04-sequencing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/Sequencer/Engine/ClockEngine.swift
  - Sources/Sequencer/Models/TransportState.swift
  - Sources/Sequencer/Engine/TapTempo.swift
autonomous: true

must_haves:
  truths:
    - "MIDI clock outputs at correct rate for specified BPM"
    - "User can start/stop clock playback"
    - "User can adjust tempo via numeric entry or tap tempo"
    - "Clock maintains stable timing without drift"
  artifacts:
    - path: "Sources/Sequencer/Engine/ClockEngine.swift"
      provides: "MIDI clock generation with DispatchSourceTimer"
      min_lines: 80
      contains: "DispatchSourceTimer"
    - path: "Sources/Sequencer/Models/TransportState.swift"
      provides: "Transport state enum (stopped, playing, recording)"
      exports: ["TransportState"]
    - path: "Sources/Sequencer/Engine/TapTempo.swift"
      provides: "Tap tempo calculation from user taps"
      min_lines: 30
  key_links:
    - from: "Sources/Sequencer/Engine/ClockEngine.swift"
      to: "MIDIConnectionManager"
      via: "send MIDI clock events through existing output connection"
      pattern: "MIDIConnectionManager\\.shared"
---

<objective>
Implement MIDI clock engine with precise timing for Eurorack sync.

Purpose: Enable the app to output MIDI clock signals that sync external Eurorack modules to the app's tempo. This is the foundational timing infrastructure for the entire sequencer.

Output: ClockEngine that generates MIDI clock at 24/48/96 PPQN, TransportState for playback control, TapTempo for live tempo input.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-sequencing/04-CONTEXT.md
@.planning/phases/04-sequencing/04-RESEARCH.md
@Sources/Managers/MIDIConnectionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transport state and clock engine foundation</name>
  <files>
    Sources/Sequencer/Models/TransportState.swift
    Sources/Sequencer/Engine/ClockEngine.swift
  </files>
  <action>
Create the Sequencer directory structure: Sources/Sequencer/Models/ and Sources/Sequencer/Engine/.

Create TransportState.swift with enum:
```swift
enum TransportState {
    case stopped
    case playing
    case recording
}
```

Create ClockEngine.swift as a class conforming to @unchecked Sendable:
- Properties: bpm (Double, 20-300, default 120), ppqn (Int, 24/48/96), transportState (TransportState)
- Private: DispatchSourceTimer on dedicated queue with .userInteractive QoS
- Private: tickCount for tracking position
- Methods: start(), stop(), continue_(), updateTimerInterval()
- Use MIDIConnectionManager.shared to send clock events

Clock interval formula: 60.0 / (bpm * Double(ppqn)) seconds

Send these MIDIKit events:
- On start(): .start() then begin timer
- On each tick: .timingClock()
- On stop(): cancel timer then .stop()
- On continue_(): .continue() then resume timer (note: method named continue_ to avoid Swift keyword)

Set timer leeway to .nanoseconds(0) for precision. Use schedule(deadline:repeating:leeway:) API.

IMPORTANT: Use @Observable macro for ClockEngine so UI can observe transportState and bpm changes. Mark the class as @MainActor-isolated for thread safety with UI, but run the timer on a background queue.
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
ClockEngine compiles without errors
  </verify>
  <done>
ClockEngine exists with start/stop/continue methods, DispatchSourceTimer-based timing, and integration with MIDIConnectionManager for sending clock events
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tap tempo and BPM configuration</name>
  <files>
    Sources/Sequencer/Engine/TapTempo.swift
    Sources/Sequencer/Engine/ClockEngine.swift
  </files>
  <action>
Create TapTempo.swift:
```swift
class TapTempo {
    private var tapTimes: [Date] = []
    private let maxTaps = 4
    private let tapTimeout: TimeInterval = 2.0

    func tap() -> Double? {
        let now = Date()

        // Reset if too long since last tap
        if let lastTap = tapTimes.last,
           now.timeIntervalSince(lastTap) > tapTimeout {
            tapTimes.removeAll()
        }

        tapTimes.append(now)

        // Keep only recent taps
        if tapTimes.count > maxTaps {
            tapTimes.removeFirst()
        }

        // Need at least 2 taps for interval
        guard tapTimes.count >= 2 else { return nil }

        // Calculate average interval
        var totalInterval: TimeInterval = 0
        for i in 1..<tapTimes.count {
            totalInterval += tapTimes[i].timeIntervalSince(tapTimes[i-1])
        }
        let avgInterval = totalInterval / Double(tapTimes.count - 1)

        // Convert to BPM, clamped to valid range
        let bpm = 60.0 / avgInterval
        return max(20.0, min(300.0, bpm))
    }

    func reset() {
        tapTimes.removeAll()
    }
}
```

Update ClockEngine to add:
- Property: tapTempo (private TapTempo instance)
- Method: processTap() -> Double? that calls tapTempo.tap() and optionally updates bpm if result is non-nil
- Property: ppqnOptions = [24, 48, 96] for UI picker
- Computed property: clockIntervalMs for debugging (return interval in milliseconds)

Add BPM validation in the bpm setter to clamp to 20-300 range.
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
TapTempo compiles and ClockEngine has processTap method
  </verify>
  <done>
TapTempo calculates BPM from tap intervals, ClockEngine integrates tap tempo and provides BPM configuration with validation
  </done>
</task>

<task type="auto">
  <name>Task 3: Add MIDI send methods to ClockEngine</name>
  <files>
    Sources/Sequencer/Engine/ClockEngine.swift
    Sources/Managers/MIDIConnectionManager.swift
  </files>
  <action>
Add helper methods to MIDIConnectionManager for sending system real-time messages:
```swift
/// Send MIDI system real-time event (clock, start, stop, continue)
func sendSystemRealTime(event: MIDIEvent) throws {
    guard let connection = midiManager.managedOutputConnections[outputConnectionTag] else {
        throw MIDIConnectionError.deviceUnavailable
    }
    try connection.send(event: event)
}
```

Update ClockEngine to use this method for all clock events. Handle errors gracefully - log but don't crash if device disconnected mid-playback.

Add Song Position Pointer support:
- Property: currentBeat (Int) tracking position in MIDI beats (1 beat = 6 clocks at 24 PPQN)
- Method: sendSongPositionPointer() that sends .songPositionPointer(midiBeat:) when needed
- Reset currentBeat to 0 on start(), increment appropriately on each tick

Add clock behavior mode enum:
```swift
enum ClockMode: String, CaseIterable {
    case auto      // Start clock when transport plays
    case manual    // Clock controlled via separate button
    case always    // Clock always running
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
MIDIConnectionManager has sendSystemRealTime method
ClockEngine sends proper MIDI events
  </verify>
  <done>
ClockEngine sends MIDI clock, start, stop, continue, and song position pointer events through MIDIConnectionManager
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds without warnings
2. ClockEngine can be instantiated
3. Timer interval calculation is correct: 120 BPM at 24 PPQN = 20.83ms
4. All MIDIKit events compile (.timingClock(), .start(), .stop(), .continue(), .songPositionPointer())
</verification>

<success_criteria>
- ClockEngine generates MIDI clock at configurable BPM (20-300) and PPQN (24/48/96)
- TransportState enum captures stopped/playing/recording states
- TapTempo calculates BPM from 2-4 tap intervals with 2 second timeout
- Clock events sent through existing MIDIConnectionManager output connection
- Timer uses DispatchSourceTimer with zero leeway for precision
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequencing/04-01-SUMMARY.md`
</output>
