---
phase: 04-sequencing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/Sequencer/Models/Pattern.swift
  - Sources/Sequencer/Models/Track.swift
  - Sources/Sequencer/Models/StepNote.swift
autonomous: true

must_haves:
  truths:
    - "Pattern contains tracks with step notes"
    - "Models are Codable for persistence"
    - "Models support version migration"
    - "Track has mute/solo/volume controls"
  artifacts:
    - path: "Sources/Sequencer/Models/Pattern.swift"
      provides: "Pattern data model with tracks, swing, trigger mode"
      exports: ["Pattern", "TriggerMode", "LaunchQuantize"]
      contains: "Codable"
    - path: "Sources/Sequencer/Models/Track.swift"
      provides: "Track data model with channel, notes, mute/solo"
      exports: ["Track"]
    - path: "Sources/Sequencer/Models/StepNote.swift"
      provides: "StepNote data model with step, note, velocity, duration"
      exports: ["StepNote"]
  key_links:
    - from: "Sources/Sequencer/Models/Pattern.swift"
      to: "Sources/Sequencer/Models/Track.swift"
      via: "tracks: [Track] property"
      pattern: "var tracks: \\[Track\\]"
    - from: "Sources/Sequencer/Models/Track.swift"
      to: "Sources/Sequencer/Models/StepNote.swift"
      via: "notes: [StepNote] property"
      pattern: "var notes: \\[StepNote\\]"
---

<objective>
Create pattern data models for step sequencer storage and manipulation.

Purpose: Define the data structures that represent musical patterns, tracks, and notes. These models are the foundation for pattern creation, editing, storage, and playback.

Output: Codable Pattern, Track, and StepNote models with version support for future migrations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-sequencing/04-CONTEXT.md
@.planning/phases/04-sequencing/04-RESEARCH.md
@Sources/Models/DeviceProfile.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StepNote and Track models</name>
  <files>
    Sources/Sequencer/Models/StepNote.swift
    Sources/Sequencer/Models/Track.swift
  </files>
  <action>
Create Sources/Sequencer/Models/ directory if not exists.

Create StepNote.swift:
```swift
import Foundation

/// A single note event in a step sequencer track
struct StepNote: Codable, Identifiable, Equatable {
    let id: UUID
    /// Step position (0-based index)
    var step: Int
    /// MIDI note number (0-127)
    var note: UInt8
    /// Velocity (1-127)
    var velocity: UInt8
    /// Duration in steps (1.0 = full step, 0.5 = half step, etc.)
    var duration: Double

    init(id: UUID = UUID(), step: Int, note: UInt8, velocity: UInt8 = 100, duration: Double = 1.0) {
        self.id = id
        self.step = step
        self.note = note
        self.velocity = velocity
        self.duration = duration
    }
}
```

Create Track.swift:
```swift
import Foundation

/// A single track in a pattern (represents one MIDI channel)
struct Track: Codable, Identifiable, Equatable {
    let id: UUID
    /// MIDI channel (1-16, 1-indexed for UI consistency)
    var channel: UInt8
    /// Note events in this track
    var notes: [StepNote]
    /// Track is muted (no output)
    var isMuted: Bool
    /// Track is soloed (only soloed tracks play)
    var isSoloed: Bool
    /// Track volume (0.0-1.0)
    var volume: Double
    /// Track name for UI display
    var name: String

    init(
        id: UUID = UUID(),
        channel: UInt8 = 1,
        notes: [StepNote] = [],
        isMuted: Bool = false,
        isSoloed: Bool = false,
        volume: Double = 1.0,
        name: String = "Track"
    ) {
        self.id = id
        self.channel = channel
        self.notes = notes
        self.isMuted = isMuted
        self.isSoloed = isSoloed
        self.volume = volume
        self.name = name
    }
}
```

Follow the pattern from DeviceProfile.swift for Codable conformance. Use default values for all properties.
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
StepNote and Track compile without errors
  </verify>
  <done>
StepNote represents individual note events with step position, note number, velocity, and duration. Track contains a collection of notes with mute/solo/volume controls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Pattern model with enums</name>
  <files>
    Sources/Sequencer/Models/Pattern.swift
  </files>
  <action>
Create Pattern.swift with supporting enums:

```swift
import Foundation
import SwiftUI

/// How a pattern is triggered during performance
enum TriggerMode: String, Codable, CaseIterable {
    case oneShot    // Play once then stop
    case toggle     // Toggle on/off with each trigger
    case momentary  // Play while held, stop on release
}

/// When a pattern starts after being triggered
enum LaunchQuantize: String, Codable, CaseIterable {
    case none  // Start immediately
    case beat  // Start on next beat
    case bar   // Start on next bar (4 beats)
}

/// A musical pattern containing tracks of step notes
struct Pattern: Codable, Identifiable, Equatable {
    /// Schema version for future migrations
    static let currentVersion = 1
    var version: Int = Pattern.currentVersion

    let id: UUID
    /// User-assigned pattern name
    var name: String
    /// Color for visual identification (stored as hex string)
    var colorHex: String
    /// Number of steps in pattern (1-64)
    var stepCount: Int
    /// Tracks in this pattern (1-16)
    var tracks: [Track]
    /// Swing amount (0.0 = no swing, 1.0 = full triplet swing)
    var swing: Double
    /// How pattern is triggered in performance mode
    var triggerMode: TriggerMode
    /// When pattern starts after trigger
    var launchQuantize: LaunchQuantize
    /// Beats per bar for this pattern (typically 4)
    var beatsPerBar: Int

    // Metadata
    var createdAt: Date
    var modifiedAt: Date

    init(
        id: UUID = UUID(),
        name: String = "New Pattern",
        colorHex: String = "4A90D9",  // Default blue
        stepCount: Int = 16,
        tracks: [Track] = [Track()],
        swing: Double = 0.0,
        triggerMode: TriggerMode = .toggle,
        launchQuantize: LaunchQuantize = .bar,
        beatsPerBar: Int = 4,
        createdAt: Date = Date(),
        modifiedAt: Date = Date()
    ) {
        self.id = id
        self.name = name
        self.colorHex = colorHex
        self.stepCount = stepCount
        self.tracks = tracks
        self.swing = swing
        self.triggerMode = triggerMode
        self.launchQuantize = launchQuantize
        self.beatsPerBar = beatsPerBar
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }

    /// Convert hex string to SwiftUI Color
    var color: Color {
        Color(hex: colorHex) ?? .blue
    }

    /// Create a pattern with default single track
    static func newPattern(name: String = "New Pattern") -> Pattern {
        Pattern(
            name: name,
            tracks: [Track(channel: 1, name: "Track 1")]
        )
    }
}

// MARK: - Color Hex Extension
extension Color {
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")

        guard hexSanitized.count == 6 else { return nil }

        var rgb: UInt64 = 0
        Scanner(string: hexSanitized).scanHexInt64(&rgb)

        self.init(
            red: Double((rgb & 0xFF0000) >> 16) / 255.0,
            green: Double((rgb & 0x00FF00) >> 8) / 255.0,
            blue: Double(rgb & 0x0000FF) / 255.0
        )
    }

    func toHex() -> String {
        // This is a simplified implementation; full implementation would extract RGB components
        "4A90D9"  // Placeholder - implement properly if needed
    }
}
```

Follow DeviceProfile.swift pattern for versioning. Include CodingKeys and custom init(from:) for migration support:

```swift
// Add to Pattern struct:
enum CodingKeys: String, CodingKey {
    case version, id, name, colorHex, stepCount, tracks, swing
    case triggerMode, launchQuantize, beatsPerBar, createdAt, modifiedAt
}

init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)

    // Handle version migration
    version = try container.decodeIfPresent(Int.self, forKey: .version) ?? 1

    id = try container.decode(UUID.self, forKey: .id)
    name = try container.decode(String.self, forKey: .name)
    colorHex = try container.decodeIfPresent(String.self, forKey: .colorHex) ?? "4A90D9"
    stepCount = try container.decode(Int.self, forKey: .stepCount)
    tracks = try container.decode([Track].self, forKey: .tracks)
    swing = try container.decodeIfPresent(Double.self, forKey: .swing) ?? 0.0
    triggerMode = try container.decodeIfPresent(TriggerMode.self, forKey: .triggerMode) ?? .toggle
    launchQuantize = try container.decodeIfPresent(LaunchQuantize.self, forKey: .launchQuantize) ?? .bar
    beatsPerBar = try container.decodeIfPresent(Int.self, forKey: .beatsPerBar) ?? 4
    createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt) ?? Date()
    modifiedAt = try container.decodeIfPresent(Date.self, forKey: .modifiedAt) ?? Date()

    // Apply migrations for older versions
    if version < Pattern.currentVersion {
        // Future migrations go here
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
Pattern compiles with all properties and enums
  </verify>
  <done>
Pattern model contains tracks, step count, swing, trigger mode, launch quantize, and metadata. Supports versioned migration through custom Codable implementation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add helper methods for pattern manipulation</name>
  <files>
    Sources/Sequencer/Models/Pattern.swift
    Sources/Sequencer/Models/Track.swift
  </files>
  <action>
Add helper methods to Track:
```swift
extension Track {
    /// Add a note to the track
    mutating func addNote(_ note: StepNote) {
        notes.append(note)
    }

    /// Remove a note by ID
    mutating func removeNote(id: UUID) {
        notes.removeAll { $0.id == id }
    }

    /// Get note at a specific step (returns first match if multiple)
    func note(at step: Int) -> StepNote? {
        notes.first { $0.step == step }
    }

    /// Get all notes at a specific step
    func notes(at step: Int) -> [StepNote] {
        notes.filter { $0.step == step }
    }

    /// Clear all notes
    mutating func clearNotes() {
        notes.removeAll()
    }

    /// Check if track should play (considering mute/solo logic)
    func shouldPlay(anySoloed: Bool) -> Bool {
        if isMuted { return false }
        if anySoloed { return isSoloed }
        return true
    }
}
```

Add helper methods to Pattern:
```swift
extension Pattern {
    /// Check if any track is soloed
    var anySoloed: Bool {
        tracks.contains { $0.isSoloed }
    }

    /// Add a new track
    mutating func addTrack(channel: UInt8? = nil) {
        let newChannel = channel ?? UInt8(tracks.count + 1)
        let track = Track(
            channel: min(newChannel, 16),
            name: "Track \(tracks.count + 1)"
        )
        tracks.append(track)
    }

    /// Remove track by ID
    mutating func removeTrack(id: UUID) {
        tracks.removeAll { $0.id == id }
    }

    /// Update modified timestamp
    mutating func touch() {
        modifiedAt = Date()
    }

    /// Get track by index (safe)
    func track(at index: Int) -> Track? {
        guard index >= 0 && index < tracks.count else { return nil }
        return tracks[index]
    }

    /// Duplicate pattern with new ID
    func duplicate(newName: String? = nil) -> Pattern {
        var copy = self
        copy.id = UUID()
        copy.name = newName ?? "\(name) Copy"
        copy.createdAt = Date()
        copy.modifiedAt = Date()
        return copy
    }

    /// Step count presets
    static let stepCountPresets = [8, 16, 32, 64]
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
Helper methods compile and are accessible
  </verify>
  <done>
Pattern and Track have helper methods for adding/removing notes and tracks, checking solo/mute state, and duplicating patterns.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds without warnings
2. Pattern, Track, StepNote all conform to Codable
3. Can create a new pattern: Pattern.newPattern()
4. Can add notes to track and tracks to pattern
5. TriggerMode and LaunchQuantize enums are available
</verification>

<success_criteria>
- StepNote stores step position, note, velocity, and duration
- Track stores channel, notes array, mute/solo/volume, and name
- Pattern stores tracks, step count (1-64), swing, trigger mode, launch quantize
- All models are Codable with version support for future migration
- Helper methods allow easy manipulation of patterns and tracks
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequencing/04-02-SUMMARY.md`
</output>
