---
phase: 04-sequencing
plan: 06
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - Sources/Sequencer/Engine/SequencerEngine.swift
  - Sources/Sequencer/Engine/ClockEngine.swift
  - Sources/Sequencer/Views/PatternBrowserView.swift
autonomous: true

must_haves:
  truths:
    - "Patterns play back notes at correct timing"
    - "User can browse and select patterns from banks"
    - "User can trigger patterns during performance"
    - "Track mute/solo affects playback output"
  artifacts:
    - path: "Sources/Sequencer/Engine/SequencerEngine.swift"
      provides: "Pattern playback engine with note scheduling"
      min_lines: 80
      contains: "scheduleNotes"
    - path: "Sources/Sequencer/Views/PatternBrowserView.swift"
      provides: "Grid view for pattern bank browsing"
      min_lines: 60
  key_links:
    - from: "Sources/Sequencer/Engine/SequencerEngine.swift"
      to: "Sources/Sequencer/Engine/ClockEngine.swift"
      via: "receives tick callbacks for note scheduling"
      pattern: "ClockEngine"
    - from: "Sources/Sequencer/Engine/SequencerEngine.swift"
      to: "Sources/Managers/MIDIConnectionManager.swift"
      via: "sends note on/off events"
      pattern: "MIDIConnectionManager"
    - from: "Sources/Sequencer/Views/PatternBrowserView.swift"
      to: "SequencerView"
      via: "returns pattern AND location tuple"
      pattern: "onSelect.*Pattern.*bank.*slot"
---

<objective>
Implement pattern playback engine and pattern browser UI.

Purpose: Enable patterns to play back through MIDI, synchronized to the clock engine. Provide a visual browser for selecting patterns from banks during performance.

Output: SequencerEngine that schedules note playback, PatternBrowserView for pattern selection with location tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-sequencing/04-CONTEXT.md
@.planning/phases/04-sequencing/04-01-SUMMARY.md
@Sources/Sequencer/Engine/ClockEngine.swift
@Sources/Sequencer/Models/Pattern.swift
@Sources/Sequencer/Managers/PatternManager.swift
@Sources/Managers/MIDIConnectionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SequencerEngine for pattern playback</name>
  <files>
    Sources/Sequencer/Engine/SequencerEngine.swift
    Sources/Sequencer/Engine/ClockEngine.swift
  </files>
  <action>
Create SequencerEngine.swift to handle pattern playback:

```swift
import Foundation
import MIDIKitCore
import Observation

/// Engine for playing back patterns synchronized to clock
@Observable
final class SequencerEngine {
    static let shared = SequencerEngine()

    // MARK: - Properties

    /// Currently playing pattern
    var activePattern: Pattern?

    /// Current step position (0-based)
    private(set) var currentStep: Int = 0

    /// Notes currently playing (for note-off tracking)
    private var activeNotes: [(note: UInt7, channel: UInt4, offStep: Int)] = []

    /// Reference to clock engine
    private let clockEngine: ClockEngine

    /// Ticks per step (varies by PPQN and step resolution)
    private var ticksPerStep: Int {
        // Assuming 16th note steps: 1 step = 1 quarter note / 4
        // At 24 PPQN: 24 / 4 = 6 ticks per step
        clockEngine.ppqn / 4
    }

    /// Current tick within step
    private var tickInStep: Int = 0

    // MARK: - Initialization

    private init() {
        clockEngine = ClockEngine.shared
        setupTickCallback()
    }

    // MARK: - Tick Callback

    private func setupTickCallback() {
        // ClockEngine will call this on each tick
        clockEngine.onTick = { [weak self] in
            self?.processTick()
        }
    }

    private func processTick() {
        guard let pattern = activePattern else { return }
        guard clockEngine.transportState == .playing else { return }

        tickInStep += 1

        // Check for step boundary
        if tickInStep >= ticksPerStep {
            tickInStep = 0
            advanceStep(pattern: pattern)
        }

        // Process note-offs
        processNoteOffs()
    }

    // MARK: - Step Advancement

    private func advanceStep(pattern: Pattern) {
        // Move to next step
        currentStep = (currentStep + 1) % pattern.stepCount

        // If we wrapped to step 0, we completed a cycle
        if currentStep == 0 {
            tickInStep = 0
        }

        // Schedule notes for this step
        scheduleNotesForCurrentStep(pattern: pattern)
    }

    // MARK: - Note Scheduling

    private func scheduleNotesForCurrentStep(pattern: Pattern) {
        let anySoloed = pattern.anySoloed

        for track in pattern.tracks {
            // Check if track should play
            guard track.shouldPlay(anySoloed: anySoloed) else { continue }

            // Get notes at current step
            let notes = track.notes(at: currentStep)

            for note in notes {
                sendNoteOn(note: note, track: track, pattern: pattern)
            }
        }
    }

    private func sendNoteOn(note: StepNote, track: Track, pattern: Pattern) {
        let midiNote = UInt7(note.note)
        // Convert 1-indexed track channel to 0-indexed MIDI channel
        let midiChannel = UInt4(track.channel - 1)

        // Apply track volume to velocity
        let adjustedVelocity = UInt7(Double(note.velocity) * track.volume)

        // Send note on
        do {
            try MIDIConnectionManager.shared.sendNoteOn(note: midiNote, velocity: adjustedVelocity)
        } catch {
            print("Failed to send note on: \(error)")
        }

        // Calculate when to send note-off (in steps)
        let offStep = (currentStep + Int(note.duration)) % (activePattern?.stepCount ?? 16)

        // Track for note-off
        activeNotes.append((note: midiNote, channel: midiChannel, offStep: offStep))
    }

    private func processNoteOffs() {
        // Find notes that need to be turned off
        let notesToOff = activeNotes.filter { $0.offStep == currentStep }

        for noteInfo in notesToOff {
            do {
                try MIDIConnectionManager.shared.sendNoteOff(note: noteInfo.note)
            } catch {
                print("Failed to send note off: \(error)")
            }
        }

        // Remove processed notes
        activeNotes.removeAll { $0.offStep == currentStep }
    }

    // MARK: - Transport Control

    func play(pattern: Pattern) {
        activePattern = pattern
        currentStep = 0
        tickInStep = 0
        activeNotes.removeAll()
        clockEngine.start()
    }

    func stop() {
        // Send all notes off
        allNotesOff()

        clockEngine.stop()
        currentStep = 0
        tickInStep = 0
        activeNotes.removeAll()
    }

    func pause() {
        // Send all notes off but maintain position
        allNotesOff()
        clockEngine.stop()
    }

    private func allNotesOff() {
        for noteInfo in activeNotes {
            try? MIDIConnectionManager.shared.sendNoteOff(note: noteInfo.note)
        }
        activeNotes.removeAll()
    }

    // MARK: - Pattern Switching

    /// Switch to a new pattern (respects launch quantize)
    func switchPattern(_ newPattern: Pattern, quantize: LaunchQuantize = .bar) {
        switch quantize {
        case .none:
            activePattern = newPattern
            // Don't reset step - continue playing

        case .beat:
            // TODO: Wait for next beat boundary
            activePattern = newPattern

        case .bar:
            // TODO: Wait for next bar boundary
            activePattern = newPattern
        }
    }
}
```

**CROSS-PLAN MODIFICATION:** Update ClockEngine.swift (created in Plan 04-01, Wave 1) to add the onTick callback property. This modification is necessary because SequencerEngine needs to receive tick notifications from ClockEngine.

Add to ClockEngine.swift:
```swift
// Add property near top of class:
var onTick: (() -> Void)?

// In the tick() method, after sending timingClock, add callback:
private func tick() {
    try? midiConnection.send(event: .timingClock())
    tickCount += 1

    // Notify sequencer engine of each tick
    onTick?()
}
```

This is an additive change that does not break existing ClockEngine functionality.
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
SequencerEngine compiles with playback logic
ClockEngine has onTick property
  </verify>
  <done>
SequencerEngine schedules note playback synchronized to clock ticks, handles note-on/off, and respects track mute/solo/volume. ClockEngine updated with onTick callback for sequencer integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PatternBrowserView for pattern selection</name>
  <files>
    Sources/Sequencer/Views/PatternBrowserView.swift
  </files>
  <action>
Create PatternBrowserView.swift with bank/slot grid.

IMPORTANT: The onSelect callback must return both the Pattern AND its location (bank, slot) tuple.
This is required by SequencerView (Plan 05) for proper pattern persistence via editingPatternLocation.

```swift
import SwiftUI

/// Grid view for browsing and selecting patterns from banks
struct PatternBrowserView: View {
    @ObservedObject private var patternManager = PatternManager.shared

    /// Callback returns Pattern AND its location for persistence tracking
    let onSelect: (Pattern, (bank: Int, slot: Int)) -> Void

    @State private var selectedBankIndex: Int = 0

    private let columns = Array(repeating: GridItem(.flexible(), spacing: 8), count: 4)

    var body: some View {
        VStack(spacing: 0) {
            // Bank tabs
            bankTabBar

            Divider()

            // Pattern grid
            ScrollView {
                patternGrid
                    .padding()
            }
        }
    }

    // MARK: - Bank Tab Bar

    private var bankTabBar: some View {
        HStack(spacing: 0) {
            ForEach(0..<PatternBank.bankCount, id: \.self) { index in
                Button {
                    selectedBankIndex = index
                } label: {
                    Text("Bank \(patternManager.banks[index].letter)")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(selectedBankIndex == index ? Color.accentColor : Color.clear)
                        .foregroundColor(selectedBankIndex == index ? .white : .primary)
                }
                .buttonStyle(.plain)
            }
        }
        .background(Color(.secondarySystemBackground))
    }

    // MARK: - Pattern Grid

    private var patternGrid: some View {
        LazyVGrid(columns: columns, spacing: 8) {
            ForEach(0..<PatternBank.patternsPerBank, id: \.self) { slot in
                PatternSlotButton(
                    pattern: patternManager.loadPattern(bank: selectedBankIndex, slot: slot),
                    slotLabel: patternManager.slotIdentifier(bank: selectedBankIndex, slot: slot),
                    onTap: {
                        if let pattern = patternManager.loadPattern(bank: selectedBankIndex, slot: slot) {
                            // Return pattern AND location tuple
                            onSelect(pattern, (bank: selectedBankIndex, slot: slot))
                        }
                    },
                    onLongPress: {
                        // Could show context menu for delete/duplicate
                    }
                )
            }
        }
    }
}

// MARK: - Pattern Slot Button

struct PatternSlotButton: View {
    let pattern: Pattern?
    let slotLabel: String
    let onTap: () -> Void
    let onLongPress: () -> Void

    var body: some View {
        Button(action: onTap) {
            VStack(spacing: 4) {
                // Slot number
                Text(slotLabel)
                    .font(.caption2)
                    .foregroundColor(.secondary)

                // Pattern indicator
                RoundedRectangle(cornerRadius: 8)
                    .fill(pattern?.color ?? Color(.tertiarySystemFill))
                    .frame(height: 50)
                    .overlay(
                        Group {
                            if pattern == nil {
                                Image(systemName: "plus")
                                    .foregroundColor(.secondary)
                            }
                        }
                    )

                // Pattern name
                Text(pattern?.name ?? "Empty")
                    .font(.caption)
                    .lineLimit(1)
                    .foregroundColor(pattern != nil ? .primary : .secondary)
            }
        }
        .buttonStyle(.plain)
        .disabled(pattern == nil)
        .simultaneousGesture(
            LongPressGesture(minimumDuration: 0.5)
                .onEnded { _ in
                    onLongPress()
                }
        )
    }
}

#Preview {
    PatternBrowserView { pattern, location in
        print("Selected: \(pattern.name) at bank \(location.bank), slot \(location.slot)")
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PatternBrowserView displays bank tabs and pattern grid
onSelect callback signature matches Plan 05 expectations
  </verify>
  <done>
PatternBrowserView shows bank tabs (A-D) and a 4x4 grid of pattern slots with colors and names. Callback returns pattern AND location tuple for SequencerView persistence tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add performance pad triggers for patterns</name>
  <files>
    Sources/Sequencer/Views/PatternBrowserView.swift
    Sources/Sequencer/Engine/SequencerEngine.swift
  </files>
  <action>
Add performance mode to PatternBrowserView where pads trigger patterns:

```swift
// Add to PatternBrowserView.swift:

/// Performance mode - pads trigger pattern playback
struct PatternPerformanceView: View {
    @ObservedObject private var patternManager = PatternManager.shared
    @State private var sequencerEngine = SequencerEngine.shared
    @State private var selectedBankIndex: Int = 0
    @State private var activePatternIds: Set<UUID> = []

    private let columns = Array(repeating: GridItem(.flexible(), spacing: 8), count: 4)

    var body: some View {
        VStack(spacing: 0) {
            // Bank tabs
            bankTabBar

            Divider()

            // Performance pad grid
            ScrollView {
                performanceGrid
                    .padding()
            }

            // Active patterns indicator
            activePatternBar
        }
    }

    private var bankTabBar: some View {
        HStack(spacing: 0) {
            ForEach(0..<PatternBank.bankCount, id: \.self) { index in
                Button {
                    selectedBankIndex = index
                } label: {
                    Text("Bank \(patternManager.banks[index].letter)")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(selectedBankIndex == index ? Color.accentColor : Color.clear)
                        .foregroundColor(selectedBankIndex == index ? .white : .primary)
                }
                .buttonStyle(.plain)
            }
        }
        .background(Color(.secondarySystemBackground))
    }

    private var performanceGrid: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(0..<PatternBank.patternsPerBank, id: \.self) { slot in
                PerformancePadButton(
                    pattern: patternManager.loadPattern(bank: selectedBankIndex, slot: slot),
                    slotLabel: patternManager.slotIdentifier(bank: selectedBankIndex, slot: slot),
                    isActive: isPatternActive(bank: selectedBankIndex, slot: slot),
                    onTrigger: {
                        triggerPattern(bank: selectedBankIndex, slot: slot)
                    }
                )
            }
        }
    }

    private var activePatternBar: some View {
        HStack {
            Text("Active: ")
                .font(.caption)
                .foregroundColor(.secondary)

            if activePatternIds.isEmpty {
                Text("None")
                    .font(.caption)
                    .foregroundColor(.secondary)
            } else {
                ForEach(Array(activePatternIds), id: \.self) { id in
                    if let location = findPatternLocation(id: id),
                       let pattern = patternManager.loadPattern(bank: location.bank, slot: location.slot) {
                        HStack(spacing: 4) {
                            Circle()
                                .fill(pattern.color)
                                .frame(width: 8, height: 8)
                            Text(pattern.name)
                                .font(.caption)
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Capsule().fill(Color(.tertiarySystemBackground)))
                    }
                }
            }

            Spacer()
        }
        .padding()
        .background(Color(.systemBackground))
    }

    private func isPatternActive(bank: Int, slot: Int) -> Bool {
        guard let pattern = patternManager.loadPattern(bank: bank, slot: slot) else { return false }
        return activePatternIds.contains(pattern.id)
    }

    private func triggerPattern(bank: Int, slot: Int) {
        guard let pattern = patternManager.loadPattern(bank: bank, slot: slot) else { return }

        switch pattern.triggerMode {
        case .oneShot:
            // Play once and remove from active
            sequencerEngine.play(pattern: pattern)
            activePatternIds.insert(pattern.id)
            // TODO: Remove after pattern completes

        case .toggle:
            if activePatternIds.contains(pattern.id) {
                activePatternIds.remove(pattern.id)
                // If this was the only active pattern, stop
                if activePatternIds.isEmpty {
                    sequencerEngine.stop()
                }
            } else {
                activePatternIds.insert(pattern.id)
                sequencerEngine.play(pattern: pattern)
            }

        case .momentary:
            // Handled by onPressBegan/onPressEnded (not implemented yet)
            activePatternIds.insert(pattern.id)
            sequencerEngine.play(pattern: pattern)
        }
    }

    private func findPatternLocation(id: UUID) -> (bank: Int, slot: Int)? {
        for (bankIndex, bank) in patternManager.banks.enumerated() {
            for (slot, pattern) in bank.patterns.enumerated() {
                if pattern?.id == id {
                    return (bankIndex, slot)
                }
            }
        }
        return nil
    }
}

// MARK: - Performance Pad Button

struct PerformancePadButton: View {
    let pattern: Pattern?
    let slotLabel: String
    let isActive: Bool
    let onTrigger: () -> Void

    var body: some View {
        Button(action: onTrigger) {
            VStack(spacing: 4) {
                RoundedRectangle(cornerRadius: 12)
                    .fill(pattern?.color ?? Color(.tertiarySystemFill))
                    .frame(height: 70)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isActive ? Color.white : Color.clear, lineWidth: 3)
                    )
                    .overlay(
                        Group {
                            if pattern == nil {
                                Image(systemName: "plus")
                                    .foregroundColor(.secondary)
                            } else if isActive {
                                Image(systemName: "play.fill")
                                    .foregroundColor(.white)
                            }
                        }
                    )
                    .shadow(color: isActive ? pattern?.color.opacity(0.5) ?? .clear : .clear, radius: 8)

                Text(pattern?.name ?? "Empty")
                    .font(.caption)
                    .lineLimit(1)
                    .foregroundColor(pattern != nil ? .primary : .secondary)

                Text(slotLabel)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .buttonStyle(.plain)
        .disabled(pattern == nil)
        .scaleEffect(isActive ? 1.05 : 1.0)
        .animation(.spring(response: 0.3), value: isActive)
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PatternPerformanceView allows triggering patterns from pads
  </verify>
  <done>
PatternPerformanceView provides performance-oriented pad grid where tapping triggers pattern playback with toggle/one-shot/momentary modes.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds without warnings
2. SequencerEngine plays pattern notes at correct steps
3. Note-offs sent at correct timing based on duration
4. Track mute/solo affects which notes play
5. PatternBrowserView shows banks and slots
6. PatternBrowserView returns (Pattern, location) tuple to caller
7. PatternPerformanceView allows triggering patterns
8. Active pattern state is visually indicated
</verification>

<success_criteria>
- SequencerEngine receives tick callbacks from ClockEngine
- ClockEngine.onTick property added (cross-plan modification documented)
- Notes scheduled on correct steps with proper velocity
- Note-offs sent after note duration
- Track mute/solo/volume respected during playback
- PatternBrowserView displays 4 banks of 16 slots each
- PatternBrowserView.onSelect returns (Pattern, (bank: Int, slot: Int)) tuple
- Pattern slots show color, name, and empty state
- Performance view allows pad-based pattern triggering
- Active patterns visually highlighted
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequencing/04-06-SUMMARY.md`
</output>
