---
phase: 04-sequencing
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - Sources/Sequencer/Engine/SequencerEngine.swift
  - Sources/Sequencer/Views/PatternBrowserView.swift
autonomous: true

must_haves:
  truths:
    - "Patterns play back notes at correct timing"
    - "User can browse and select patterns from banks"
    - "User can trigger patterns during performance"
    - "Track mute/solo affects playback output"
  artifacts:
    - path: "Sources/Sequencer/Engine/SequencerEngine.swift"
      provides: "Pattern playback engine with note scheduling"
      min_lines: 80
      contains: "scheduleNotes"
    - path: "Sources/Sequencer/Views/PatternBrowserView.swift"
      provides: "Grid view for pattern bank browsing"
      min_lines: 60
  key_links:
    - from: "Sources/Sequencer/Engine/SequencerEngine.swift"
      to: "Sources/Sequencer/Engine/ClockEngine.swift"
      via: "receives tick callbacks for note scheduling"
      pattern: "ClockEngine"
    - from: "Sources/Sequencer/Engine/SequencerEngine.swift"
      to: "Sources/Managers/MIDIConnectionManager.swift"
      via: "sends note on/off events"
      pattern: "MIDIConnectionManager"
---

<objective>
Implement pattern playback engine and pattern browser UI.

Purpose: Enable patterns to play back through MIDI, synchronized to the clock engine. Provide a visual browser for selecting patterns from banks during performance.

Output: SequencerEngine that schedules note playback, PatternBrowserView for pattern selection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-sequencing/04-CONTEXT.md
@Sources/Sequencer/Engine/ClockEngine.swift
@Sources/Sequencer/Models/Pattern.swift
@Sources/Sequencer/Managers/PatternManager.swift
@Sources/Managers/MIDIConnectionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SequencerEngine for pattern playback</name>
  <files>
    Sources/Sequencer/Engine/SequencerEngine.swift
  </files>
  <action>
Create SequencerEngine.swift to handle pattern playback:

```swift
import Foundation
import MIDIKitCore
import Observation

/// Engine for playing back patterns synchronized to clock
@Observable
final class SequencerEngine {
    static let shared = SequencerEngine()

    // MARK: - Properties

    /// Currently playing pattern
    var activePattern: Pattern?

    /// Current step position (0-based)
    private(set) var currentStep: Int = 0

    /// Notes currently playing (for note-off tracking)
    private var activeNotes: [(note: UInt7, channel: UInt4, offStep: Int)] = []

    /// Reference to clock engine
    private let clockEngine: ClockEngine

    /// Ticks per step (varies by PPQN and step resolution)
    private var ticksPerStep: Int {
        // Assuming 16th note steps: 1 step = 1 quarter note / 4
        // At 24 PPQN: 24 / 4 = 6 ticks per step
        clockEngine.ppqn / 4
    }

    /// Current tick within step
    private var tickInStep: Int = 0

    // MARK: - Initialization

    private init() {
        clockEngine = ClockEngine.shared
        setupTickCallback()
    }

    // MARK: - Tick Callback

    private func setupTickCallback() {
        // ClockEngine will call this on each tick
        clockEngine.onTick = { [weak self] in
            self?.processTick()
        }
    }

    private func processTick() {
        guard let pattern = activePattern else { return }
        guard clockEngine.transportState == .playing else { return }

        tickInStep += 1

        // Check for step boundary
        if tickInStep >= ticksPerStep {
            tickInStep = 0
            advanceStep(pattern: pattern)
        }

        // Process note-offs
        processNoteOffs()
    }

    // MARK: - Step Advancement

    private func advanceStep(pattern: Pattern) {
        // Move to next step
        currentStep = (currentStep + 1) % pattern.stepCount

        // If we wrapped to step 0, we completed a cycle
        if currentStep == 0 {
            tickInStep = 0
        }

        // Schedule notes for this step
        scheduleNotesForCurrentStep(pattern: pattern)
    }

    // MARK: - Note Scheduling

    private func scheduleNotesForCurrentStep(pattern: Pattern) {
        let anySoloed = pattern.anySoloed

        for track in pattern.tracks {
            // Check if track should play
            guard track.shouldPlay(anySoloed: anySoloed) else { continue }

            // Get notes at current step
            let notes = track.notes(at: currentStep)

            for note in notes {
                sendNoteOn(note: note, track: track, pattern: pattern)
            }
        }
    }

    private func sendNoteOn(note: StepNote, track: Track, pattern: Pattern) {
        let midiNote = UInt7(note.note)
        // Convert 1-indexed track channel to 0-indexed MIDI channel
        let midiChannel = UInt4(track.channel - 1)

        // Apply track volume to velocity
        let adjustedVelocity = UInt7(Double(note.velocity) * track.volume)

        // Send note on
        do {
            try MIDIConnectionManager.shared.sendNoteOn(note: midiNote, velocity: adjustedVelocity)
        } catch {
            print("Failed to send note on: \(error)")
        }

        // Calculate when to send note-off (in steps)
        let offStep = (currentStep + Int(note.duration)) % (activePattern?.stepCount ?? 16)

        // Track for note-off
        activeNotes.append((note: midiNote, channel: midiChannel, offStep: offStep))
    }

    private func processNoteOffs() {
        // Find notes that need to be turned off
        let notesToOff = activeNotes.filter { $0.offStep == currentStep }

        for noteInfo in notesToOff {
            do {
                try MIDIConnectionManager.shared.sendNoteOff(note: noteInfo.note)
            } catch {
                print("Failed to send note off: \(error)")
            }
        }

        // Remove processed notes
        activeNotes.removeAll { $0.offStep == currentStep }
    }

    // MARK: - Transport Control

    func play(pattern: Pattern) {
        activePattern = pattern
        currentStep = 0
        tickInStep = 0
        activeNotes.removeAll()
        clockEngine.start()
    }

    func stop() {
        // Send all notes off
        allNotesOff()

        clockEngine.stop()
        currentStep = 0
        tickInStep = 0
        activeNotes.removeAll()
    }

    func pause() {
        // Send all notes off but maintain position
        allNotesOff()
        clockEngine.stop()
    }

    private func allNotesOff() {
        for noteInfo in activeNotes {
            try? MIDIConnectionManager.shared.sendNoteOff(note: noteInfo.note)
        }
        activeNotes.removeAll()
    }

    // MARK: - Pattern Switching

    /// Switch to a new pattern (respects launch quantize)
    func switchPattern(_ newPattern: Pattern, quantize: LaunchQuantize = .bar) {
        switch quantize {
        case .none:
            activePattern = newPattern
            // Don't reset step - continue playing

        case .beat:
            // TODO: Wait for next beat boundary
            activePattern = newPattern

        case .bar:
            // TODO: Wait for next bar boundary
            activePattern = newPattern
        }
    }
}
```

Update ClockEngine to support onTick callback:
```swift
// Add to ClockEngine:
var onTick: (() -> Void)?

// In tick() method, after sending timingClock:
private func tick() {
    try? midiConnection.send(event: .timingClock())
    tickCount += 1

    // Notify sequencer engine
    onTick?()
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
SequencerEngine compiles with playback logic
  </verify>
  <done>
SequencerEngine schedules note playback synchronized to clock ticks, handles note-on/off, and respects track mute/solo/volume.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PatternBrowserView for pattern selection</name>
  <files>
    Sources/Sequencer/Views/PatternBrowserView.swift
  </files>
  <action>
Create PatternBrowserView.swift with bank/slot grid:

```swift
import SwiftUI

/// Grid view for browsing and selecting patterns from banks
struct PatternBrowserView: View {
    @ObservedObject private var patternManager = PatternManager.shared
    let onSelect: (Pattern) -> Void

    @State private var selectedBankIndex: Int = 0

    private let columns = Array(repeating: GridItem(.flexible(), spacing: 8), count: 4)

    var body: some View {
        VStack(spacing: 0) {
            // Bank tabs
            bankTabBar

            Divider()

            // Pattern grid
            ScrollView {
                patternGrid
                    .padding()
            }
        }
    }

    // MARK: - Bank Tab Bar

    private var bankTabBar: some View {
        HStack(spacing: 0) {
            ForEach(0..<PatternBank.bankCount, id: \.self) { index in
                Button {
                    selectedBankIndex = index
                } label: {
                    Text("Bank \(patternManager.banks[index].letter)")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(selectedBankIndex == index ? Color.accentColor : Color.clear)
                        .foregroundColor(selectedBankIndex == index ? .white : .primary)
                }
                .buttonStyle(.plain)
            }
        }
        .background(Color(.secondarySystemBackground))
    }

    // MARK: - Pattern Grid

    private var patternGrid: some View {
        LazyVGrid(columns: columns, spacing: 8) {
            ForEach(0..<PatternBank.patternsPerBank, id: \.self) { slot in
                PatternSlotButton(
                    pattern: patternManager.loadPattern(bank: selectedBankIndex, slot: slot),
                    slotLabel: patternManager.slotIdentifier(bank: selectedBankIndex, slot: slot),
                    onTap: {
                        if let pattern = patternManager.loadPattern(bank: selectedBankIndex, slot: slot) {
                            onSelect(pattern)
                        }
                    },
                    onLongPress: {
                        // Could show context menu for delete/duplicate
                    }
                )
            }
        }
    }
}

// MARK: - Pattern Slot Button

struct PatternSlotButton: View {
    let pattern: Pattern?
    let slotLabel: String
    let onTap: () -> Void
    let onLongPress: () -> Void

    var body: some View {
        Button(action: onTap) {
            VStack(spacing: 4) {
                // Slot number
                Text(slotLabel)
                    .font(.caption2)
                    .foregroundColor(.secondary)

                // Pattern indicator
                RoundedRectangle(cornerRadius: 8)
                    .fill(pattern?.color ?? Color(.tertiarySystemFill))
                    .frame(height: 50)
                    .overlay(
                        Group {
                            if pattern == nil {
                                Image(systemName: "plus")
                                    .foregroundColor(.secondary)
                            }
                        }
                    )

                // Pattern name
                Text(pattern?.name ?? "Empty")
                    .font(.caption)
                    .lineLimit(1)
                    .foregroundColor(pattern != nil ? .primary : .secondary)
            }
        }
        .buttonStyle(.plain)
        .disabled(pattern == nil)
        .simultaneousGesture(
            LongPressGesture(minimumDuration: 0.5)
                .onEnded { _ in
                    onLongPress()
                }
        )
    }
}

// MARK: - Full Screen Browser

struct PatternBrowserSheet: View {
    let onSelect: (Pattern) -> Void
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            PatternBrowserView { pattern in
                onSelect(pattern)
                dismiss()
            }
            .navigationTitle("Select Pattern")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
            }
        }
    }
}

#Preview {
    PatternBrowserView { pattern in
        print("Selected: \(pattern.name)")
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PatternBrowserView displays bank tabs and pattern grid
  </verify>
  <done>
PatternBrowserView shows bank tabs (A-D) and a 4x4 grid of pattern slots with colors and names.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add performance pad triggers for patterns</name>
  <files>
    Sources/Sequencer/Views/PatternBrowserView.swift
    Sources/Sequencer/Engine/SequencerEngine.swift
  </files>
  <action>
Add performance mode to PatternBrowserView where pads trigger patterns:

```swift
// Add to PatternBrowserView:

/// Performance mode - pads trigger pattern playback
struct PatternPerformanceView: View {
    @ObservedObject private var patternManager = PatternManager.shared
    @State private var sequencerEngine = SequencerEngine.shared
    @State private var selectedBankIndex: Int = 0
    @State private var activePatternIds: Set<UUID> = []

    private let columns = Array(repeating: GridItem(.flexible(), spacing: 8), count: 4)

    var body: some View {
        VStack(spacing: 0) {
            // Bank tabs
            bankTabBar

            Divider()

            // Performance pad grid
            ScrollView {
                performanceGrid
                    .padding()
            }

            // Active patterns indicator
            activePatternBar
        }
    }

    private var bankTabBar: some View {
        HStack(spacing: 0) {
            ForEach(0..<PatternBank.bankCount, id: \.self) { index in
                Button {
                    selectedBankIndex = index
                } label: {
                    Text("Bank \(patternManager.banks[index].letter)")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(selectedBankIndex == index ? Color.accentColor : Color.clear)
                        .foregroundColor(selectedBankIndex == index ? .white : .primary)
                }
                .buttonStyle(.plain)
            }
        }
        .background(Color(.secondarySystemBackground))
    }

    private var performanceGrid: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(0..<PatternBank.patternsPerBank, id: \.self) { slot in
                PerformancePadButton(
                    pattern: patternManager.loadPattern(bank: selectedBankIndex, slot: slot),
                    slotLabel: patternManager.slotIdentifier(bank: selectedBankIndex, slot: slot),
                    isActive: isPatternActive(bank: selectedBankIndex, slot: slot),
                    onTrigger: {
                        triggerPattern(bank: selectedBankIndex, slot: slot)
                    }
                )
            }
        }
    }

    private var activePatternBar: some View {
        HStack {
            Text("Active: ")
                .font(.caption)
                .foregroundColor(.secondary)

            if activePatternIds.isEmpty {
                Text("None")
                    .font(.caption)
                    .foregroundColor(.secondary)
            } else {
                ForEach(Array(activePatternIds), id: \.self) { id in
                    if let location = findPatternLocation(id: id),
                       let pattern = patternManager.loadPattern(bank: location.bank, slot: location.slot) {
                        HStack(spacing: 4) {
                            Circle()
                                .fill(pattern.color)
                                .frame(width: 8, height: 8)
                            Text(pattern.name)
                                .font(.caption)
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Capsule().fill(Color(.tertiarySystemBackground)))
                    }
                }
            }

            Spacer()
        }
        .padding()
        .background(Color(.systemBackground))
    }

    private func isPatternActive(bank: Int, slot: Int) -> Bool {
        guard let pattern = patternManager.loadPattern(bank: bank, slot: slot) else { return false }
        return activePatternIds.contains(pattern.id)
    }

    private func triggerPattern(bank: Int, slot: Int) {
        guard let pattern = patternManager.loadPattern(bank: bank, slot: slot) else { return }

        switch pattern.triggerMode {
        case .oneShot:
            // Play once and remove from active
            sequencerEngine.play(pattern: pattern)
            activePatternIds.insert(pattern.id)
            // TODO: Remove after pattern completes

        case .toggle:
            if activePatternIds.contains(pattern.id) {
                activePatternIds.remove(pattern.id)
                // If this was the only active pattern, stop
                if activePatternIds.isEmpty {
                    sequencerEngine.stop()
                }
            } else {
                activePatternIds.insert(pattern.id)
                sequencerEngine.play(pattern: pattern)
            }

        case .momentary:
            // Handled by onPressBegan/onPressEnded (not implemented yet)
            activePatternIds.insert(pattern.id)
            sequencerEngine.play(pattern: pattern)
        }
    }

    private func findPatternLocation(id: UUID) -> (bank: Int, slot: Int)? {
        for (bankIndex, bank) in patternManager.banks.enumerated() {
            for (slot, pattern) in bank.patterns.enumerated() {
                if pattern?.id == id {
                    return (bankIndex, slot)
                }
            }
        }
        return nil
    }
}

// MARK: - Performance Pad Button

struct PerformancePadButton: View {
    let pattern: Pattern?
    let slotLabel: String
    let isActive: Bool
    let onTrigger: () -> Void

    var body: some View {
        Button(action: onTrigger) {
            VStack(spacing: 4) {
                RoundedRectangle(cornerRadius: 12)
                    .fill(pattern?.color ?? Color(.tertiarySystemFill))
                    .frame(height: 70)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isActive ? Color.white : Color.clear, lineWidth: 3)
                    )
                    .overlay(
                        Group {
                            if pattern == nil {
                                Image(systemName: "plus")
                                    .foregroundColor(.secondary)
                            } else if isActive {
                                Image(systemName: "play.fill")
                                    .foregroundColor(.white)
                            }
                        }
                    )
                    .shadow(color: isActive ? pattern?.color.opacity(0.5) ?? .clear : .clear, radius: 8)

                Text(pattern?.name ?? "Empty")
                    .font(.caption)
                    .lineLimit(1)
                    .foregroundColor(pattern != nil ? .primary : .secondary)

                Text(slotLabel)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .buttonStyle(.plain)
        .disabled(pattern == nil)
        .scaleEffect(isActive ? 1.05 : 1.0)
        .animation(.spring(response: 0.3), value: isActive)
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PatternPerformanceView allows triggering patterns from pads
  </verify>
  <done>
PatternPerformanceView provides performance-oriented pad grid where tapping triggers pattern playback with toggle/one-shot/momentary modes.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds without warnings
2. SequencerEngine plays pattern notes at correct steps
3. Note-offs sent at correct timing based on duration
4. Track mute/solo affects which notes play
5. PatternBrowserView shows banks and slots
6. PatternPerformanceView allows triggering patterns
7. Active pattern state is visually indicated
</verification>

<success_criteria>
- SequencerEngine receives tick callbacks from ClockEngine
- Notes scheduled on correct steps with proper velocity
- Note-offs sent after note duration
- Track mute/solo/volume respected during playback
- PatternBrowserView displays 4 banks of 16 slots each
- Pattern slots show color, name, and empty state
- Performance view allows pad-based pattern triggering
- Active patterns visually highlighted
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequencing/04-06-SUMMARY.md`
</output>
