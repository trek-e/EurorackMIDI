---
phase: 04-sequencing
plan: 03
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - Sources/Sequencer/Managers/PatternManager.swift
  - Sources/Sequencer/Models/PatternBank.swift
autonomous: true

must_haves:
  truths:
    - "User can save patterns to persistent storage"
    - "User can load saved patterns"
    - "Patterns organized in banks (4 banks of 16)"
    - "Pattern data persists across app launches"
  artifacts:
    - path: "Sources/Sequencer/Managers/PatternManager.swift"
      provides: "Pattern storage and persistence manager"
      exports: ["PatternManager"]
      contains: "ObservableObject"
    - path: "Sources/Sequencer/Models/PatternBank.swift"
      provides: "Bank structure for organizing patterns"
      exports: ["PatternBank"]
  key_links:
    - from: "Sources/Sequencer/Managers/PatternManager.swift"
      to: "Sources/Sequencer/Models/Pattern.swift"
      via: "stores and retrieves Pattern objects"
      pattern: "Pattern"
    - from: "Sources/Sequencer/Managers/PatternManager.swift"
      to: "FileManager"
      via: "saves to documents directory"
      pattern: "FileManager\\.default"
---

<objective>
Implement pattern storage manager for saving and loading patterns.

Purpose: Enable users to save their created patterns and recall them later. Patterns are organized into banks for easy browsing and performance triggering.

Output: PatternManager that persists patterns to disk, organized in 4 banks of 16 patterns each.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-sequencing/04-CONTEXT.md
@.planning/phases/04-sequencing/04-RESEARCH.md
@Sources/Managers/ProfileManager.swift
@Sources/Sequencer/Models/Pattern.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PatternBank model</name>
  <files>
    Sources/Sequencer/Models/PatternBank.swift
  </files>
  <action>
Create PatternBank.swift to organize patterns into banks:

```swift
import Foundation

/// A bank of patterns (up to 16 patterns per bank)
struct PatternBank: Codable, Identifiable {
    static let patternsPerBank = 16
    static let bankCount = 4

    let id: UUID
    /// Bank name (e.g., "Bank A", "Bank B")
    var name: String
    /// Bank index (0-3)
    let index: Int
    /// Patterns in this bank (up to 16, indexed 0-15)
    var patterns: [Pattern?]

    init(id: UUID = UUID(), name: String, index: Int) {
        self.id = id
        self.name = name
        self.index = index
        // Initialize with empty slots
        self.patterns = Array(repeating: nil, count: PatternBank.patternsPerBank)
    }

    /// Get pattern at slot (0-15)
    func pattern(at slot: Int) -> Pattern? {
        guard slot >= 0 && slot < patterns.count else { return nil }
        return patterns[slot]
    }

    /// Set pattern at slot (0-15)
    mutating func setPattern(_ pattern: Pattern?, at slot: Int) {
        guard slot >= 0 && slot < patterns.count else { return }
        patterns[slot] = pattern
    }

    /// Find first empty slot
    var firstEmptySlot: Int? {
        patterns.firstIndex(where: { $0 == nil })
    }

    /// Count of non-empty patterns
    var patternCount: Int {
        patterns.compactMap { $0 }.count
    }

    /// Bank letter (A, B, C, D)
    var letter: String {
        String(UnicodeScalar(65 + index)!)  // ASCII: A=65
    }
}

// MARK: - Default Banks
extension PatternBank {
    static func defaultBanks() -> [PatternBank] {
        (0..<bankCount).map { index in
            PatternBank(
                name: "Bank \(String(UnicodeScalar(65 + index)!))",
                index: index
            )
        }
    }
}
```

Use optional Pattern array to support empty slots in the bank.
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PatternBank compiles with correct structure
  </verify>
  <done>
PatternBank organizes up to 16 patterns per bank with support for empty slots and helper methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PatternManager for persistence</name>
  <files>
    Sources/Sequencer/Managers/PatternManager.swift
  </files>
  <action>
Create Sources/Sequencer/Managers/ directory if not exists.

Create PatternManager.swift following the ProfileManager pattern:

```swift
import Foundation
import SwiftUI
import CloudStorage

/// Manages pattern storage and persistence
class PatternManager: ObservableObject {
    static let shared = PatternManager()

    // MARK: - Published Properties

    /// All pattern banks
    @Published private(set) var banks: [PatternBank] = PatternBank.defaultBanks()

    /// Currently selected bank index
    @Published var selectedBankIndex: Int = 0

    /// Currently selected pattern (for editing)
    @Published var currentPattern: Pattern?

    // MARK: - Cloud Storage

    @CloudStorage("patternBanks") private var storedBanksData: Data?

    // MARK: - File Storage (backup)

    private let patternsDirectoryName = "Patterns"
    private let banksFileName = "banks.json"

    private var patternsDirectory: URL {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        return documentsPath.appendingPathComponent(patternsDirectoryName)
    }

    // MARK: - Initialization

    private init() {
        createPatternsDirectoryIfNeeded()
        loadBanks()
    }

    private func createPatternsDirectoryIfNeeded() {
        try? FileManager.default.createDirectory(
            at: patternsDirectory,
            withIntermediateDirectories: true
        )
    }

    // MARK: - Bank Access

    /// Get currently selected bank
    var selectedBank: PatternBank {
        banks[selectedBankIndex]
    }

    /// Get bank by index
    func bank(at index: Int) -> PatternBank? {
        guard index >= 0 && index < banks.count else { return nil }
        return banks[index]
    }

    // MARK: - Pattern Operations

    /// Save pattern to specific bank and slot
    func savePattern(_ pattern: Pattern, bank bankIndex: Int, slot: Int) {
        guard bankIndex >= 0 && bankIndex < banks.count else { return }
        guard slot >= 0 && slot < PatternBank.patternsPerBank else { return }

        var updatedPattern = pattern
        updatedPattern.touch()

        banks[bankIndex].setPattern(updatedPattern, at: slot)
        persistBanks()
    }

    /// Save pattern to first available slot in current bank
    func savePatternToFirstAvailable(_ pattern: Pattern) -> (bank: Int, slot: Int)? {
        // Try current bank first
        if let slot = banks[selectedBankIndex].firstEmptySlot {
            savePattern(pattern, bank: selectedBankIndex, slot: slot)
            return (selectedBankIndex, slot)
        }

        // Try other banks
        for (bankIndex, bank) in banks.enumerated() {
            if let slot = bank.firstEmptySlot {
                savePattern(pattern, bank: bankIndex, slot: slot)
                return (bankIndex, slot)
            }
        }

        return nil  // All slots full
    }

    /// Load pattern from bank and slot
    func loadPattern(bank bankIndex: Int, slot: Int) -> Pattern? {
        bank(at: bankIndex)?.pattern(at: slot)
    }

    /// Delete pattern from bank and slot
    func deletePattern(bank bankIndex: Int, slot: Int) {
        guard bankIndex >= 0 && bankIndex < banks.count else { return }
        banks[bankIndex].setPattern(nil, at: slot)
        persistBanks()
    }

    /// Move pattern between slots
    func movePattern(from: (bank: Int, slot: Int), to: (bank: Int, slot: Int)) {
        guard let pattern = loadPattern(bank: from.bank, slot: from.slot) else { return }
        deletePattern(bank: from.bank, slot: from.slot)
        savePattern(pattern, bank: to.bank, slot: to.slot)
    }

    /// Duplicate pattern to first available slot
    func duplicatePattern(bank bankIndex: Int, slot: Int) -> (bank: Int, slot: Int)? {
        guard let original = loadPattern(bank: bankIndex, slot: slot) else { return nil }
        let copy = original.duplicate()
        return savePatternToFirstAvailable(copy)
    }

    // MARK: - Persistence

    private func persistBanks() {
        guard let data = try? JSONEncoder().encode(banks) else { return }

        // Save to CloudStorage
        storedBanksData = data

        // Also save to local file as backup
        let fileURL = patternsDirectory.appendingPathComponent(banksFileName)
        try? data.write(to: fileURL)
    }

    private func loadBanks() {
        // Try CloudStorage first
        if let data = storedBanksData,
           let loadedBanks = try? JSONDecoder().decode([PatternBank].self, from: data) {
            banks = loadedBanks
            return
        }

        // Fall back to local file
        let fileURL = patternsDirectory.appendingPathComponent(banksFileName)
        if let data = try? Data(contentsOf: fileURL),
           let loadedBanks = try? JSONDecoder().decode([PatternBank].self, from: data) {
            banks = loadedBanks
            return
        }

        // Use defaults if nothing found
        banks = PatternBank.defaultBanks()
    }

    /// Force reload from storage
    func reload() {
        loadBanks()
    }

    /// Get total pattern count across all banks
    var totalPatternCount: Int {
        banks.reduce(0) { $0 + $1.patternCount }
    }
}
```

Use ObservableObject (not @Observable) for CloudStorage compatibility, matching ProfileManager pattern.
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
PatternManager compiles with CloudStorage and file persistence
  </verify>
  <done>
PatternManager saves/loads patterns to CloudStorage and local file backup, with bank organization and slot management.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add pattern search and export helpers</name>
  <files>
    Sources/Sequencer/Managers/PatternManager.swift
  </files>
  <action>
Add additional helper methods to PatternManager:

```swift
// MARK: - Search and Filter

extension PatternManager {
    /// Find all patterns matching a name (case-insensitive)
    func searchPatterns(name: String) -> [(bank: Int, slot: Int, pattern: Pattern)] {
        var results: [(bank: Int, slot: Int, pattern: Pattern)] = []

        for (bankIndex, bank) in banks.enumerated() {
            for (slot, pattern) in bank.patterns.enumerated() {
                if let p = pattern,
                   p.name.localizedCaseInsensitiveContains(name) {
                    results.append((bankIndex, slot, p))
                }
            }
        }

        return results
    }

    /// Get all non-empty patterns
    func allPatterns() -> [(bank: Int, slot: Int, pattern: Pattern)] {
        var results: [(bank: Int, slot: Int, pattern: Pattern)] = []

        for (bankIndex, bank) in banks.enumerated() {
            for (slot, pattern) in bank.patterns.enumerated() {
                if let p = pattern {
                    results.append((bankIndex, slot, p))
                }
            }
        }

        return results
    }

    /// Get patterns sorted by modification date (most recent first)
    func recentPatterns(limit: Int = 10) -> [(bank: Int, slot: Int, pattern: Pattern)] {
        allPatterns()
            .sorted { $0.pattern.modifiedAt > $1.pattern.modifiedAt }
            .prefix(limit)
            .map { $0 }
    }
}

// MARK: - Import/Export Data

extension PatternManager {
    /// Export single pattern as JSON data
    func exportPattern(bank bankIndex: Int, slot: Int) -> Data? {
        guard let pattern = loadPattern(bank: bankIndex, slot: slot) else { return nil }
        return try? JSONEncoder().encode(pattern)
    }

    /// Import pattern from JSON data
    func importPattern(from data: Data) -> Pattern? {
        try? JSONDecoder().decode(Pattern.self, from: data)
    }

    /// Export all banks as JSON data (for backup)
    func exportAllBanks() -> Data? {
        try? JSONEncoder().encode(banks)
    }

    /// Import banks from JSON data (replaces all)
    func importBanks(from data: Data) -> Bool {
        guard let loadedBanks = try? JSONDecoder().decode([PatternBank].self, from: data) else {
            return false
        }
        banks = loadedBanks
        persistBanks()
        return true
    }
}

// MARK: - Slot Display Helpers

extension PatternManager {
    /// Get display name for slot (pattern name or "Empty")
    func slotDisplayName(bank bankIndex: Int, slot: Int) -> String {
        loadPattern(bank: bankIndex, slot: slot)?.name ?? "Empty"
    }

    /// Check if slot is empty
    func isSlotEmpty(bank bankIndex: Int, slot: Int) -> Bool {
        loadPattern(bank: bankIndex, slot: slot) == nil
    }

    /// Get slot identifier string (e.g., "A1", "B16")
    func slotIdentifier(bank bankIndex: Int, slot: Int) -> String {
        let bankLetter = String(UnicodeScalar(65 + bankIndex)!)
        return "\(bankLetter)\(slot + 1)"
    }
}
```
  </action>
  <verify>
Build succeeds: `cd /Users/trekkie/EurorackMIDI && swift build`
Search and export methods compile correctly
  </verify>
  <done>
PatternManager has search, filter, and export capabilities for pattern management.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds without warnings
2. PatternManager.shared is accessible
3. Can save and load patterns to specific bank/slot
4. Can search patterns by name
5. Can export/import pattern data
6. Patterns persist across simulated app restarts
</verification>

<success_criteria>
- PatternBank organizes 16 pattern slots per bank, 4 banks total
- PatternManager persists to CloudStorage and local file backup
- Can save, load, delete, move, and duplicate patterns
- Search functionality finds patterns by name
- Export/import supports JSON data for backup and sharing
</success_criteria>

<output>
After completion, create `.planning/phases/04-sequencing/04-03-SUMMARY.md`
</output>
